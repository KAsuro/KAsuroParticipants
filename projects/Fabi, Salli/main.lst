   1               		.file	"main.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   7               		.text
   8               	.Ltext0:
   9               		.cfi_sections	.debug_frame
  10               		.section	.text.startup.main,"ax",@progbits
  11               	.global	main
  13               	main:
  14               	.LFB2:
  15               		.file 1 "main.c"
   1:main.c        **** /**
   2:main.c        ****  * Beschreibt hier was euer Programm macht!
   3:main.c        ****  */
   4:main.c        **** 
   5:main.c        **** #define SWITCH(X) 1<<X
   6:main.c        **** #define SLOW 1000
   7:main.c        **** #define FAST 100
   8:main.c        **** 
   9:main.c        **** #include <asuro/asuro.h>
  10:main.c        **** 
  11:main.c        **** void main(void) {
  16               		.loc 1 11 0
  17               		.cfi_startproc
  18 0000 CF93      		push r28	 ;  283	pushqi1/1	[length = 1]
  19               	.LCFI0:
  20               		.cfi_def_cfa_offset 3
  21               		.cfi_offset 28, -2
  22 0002 DF93      		push r29	 ;  284	pushqi1/1	[length = 1]
  23               	.LCFI1:
  24               		.cfi_def_cfa_offset 4
  25               		.cfi_offset 29, -3
  26               		 ; SP -= 4	 ;  288	*addhi3_sp	[length = 2]
  27 0004 00D0      		rcall .
  28 0006 00D0      		rcall .
  29               	.LCFI2:
  30               		.cfi_def_cfa_offset 8
  31 0008 CDB7      		in r28,__SP_L__	 ;  289	*movhi/8	[length = 2]
  32 000a DEB7      		in r29,__SP_H__
  33               	.LCFI3:
  34               		.cfi_def_cfa_register 28
  35               	/* prologue: function */
  36               	/* frame size = 4 */
  37               	/* stack size = 6 */
  38               	.L__stack_usage = 6
  12:main.c        ****     Init();
  39               		.loc 1 12 0
  40 000c 00D0      		rcall Init	 ;  77	call_insn/2	[length = 1]
  41               	.LVL0:
  13:main.c        **** 	int status = 0;
  14:main.c        **** 	int x = 160;
  15:main.c        **** 	int y = 200;
  42               		.loc 1 15 0
  43 000e 48EC      		ldi r20,lo8(-56)	 ;  300	*reload_inhi	[length = 3]
  44 0010 C42E      		mov r12,r20
  45 0012 D12C      		mov r13,__zero_reg__
  14:main.c        **** 	int y = 200;
  46               		.loc 1 14 0
  47 0014 00EA      		ldi r16,lo8(-96)	 ;  68	*movhi/5	[length = 2]
  48 0016 10E0      		ldi r17,0
  13:main.c        **** 	int status = 0;
  49               		.loc 1 13 0
  50 0018 E12C      		mov r14,__zero_reg__	 ;  69	*movhi/2	[length = 2]
  51 001a F12C      		mov r15,__zero_reg__
  52               	.LVL1:
  53               	.L14:
  54               	.LBB9:
  16:main.c        **** 	while (1) {
  17:main.c        **** 		char sensor = PollSwitch();
  55               		.loc 1 17 0
  56 001c 00D0      		rcall PollSwitch	 ;  85	call_value_insn/2	[length = 1]
  57               	.LVL2:
  58 001e B82E      		mov r11,r24	 ;  86	movqi_insn/1	[length = 1]
  59               	.LVL3:
  18:main.c        **** 		sensor &= 0b00111111;
  19:main.c        **** 		
  20:main.c        **** 		MotorDir(FWD, FWD);
  60               		.loc 1 20 0
  61 0020 60E2      		ldi r22,lo8(32)	 ;  89	movqi_insn/2	[length = 1]
  62 0022 80E2      		ldi r24,lo8(32)	 ;  90	movqi_insn/2	[length = 1]
  63 0024 00D0      		rcall MotorDir	 ;  91	call_insn/2	[length = 1]
  64               	.LVL4:
  21:main.c        **** 		MotorSpeed(160, 200);
  65               		.loc 1 21 0
  66 0026 68EC      		ldi r22,lo8(-56)	 ;  92	movqi_insn/2	[length = 1]
  67 0028 80EA      		ldi r24,lo8(-96)	 ;  93	movqi_insn/2	[length = 1]
  68 002a 00D0      		rcall MotorSpeed	 ;  94	call_insn/2	[length = 1]
  69               	.LVL5:
  18:main.c        **** 		sensor &= 0b00111111;
  70               		.loc 1 18 0
  71 002c 8B2D      		mov r24,r11	 ;  279	movqi_insn/1	[length = 1]
  72 002e 8F73      		andi r24,lo8(63)	 ;  95	andqi3/2	[length = 1]
  73               	.LVL6:
  22:main.c        **** 		
  23:main.c        **** 		
  24:main.c        **** 		if (sensor > 0)
  74               		.loc 1 24 0
  75 0030 01F0      		breq .L2	 ;  97	branch	[length = 1]
  25:main.c        **** 		{
  26:main.c        **** 			 MotorDir(BWD, BWD);
  76               		.loc 1 26 0
  77 0032 60E1      		ldi r22,lo8(16)	 ;  99	movqi_insn/2	[length = 1]
  78 0034 80E1      		ldi r24,lo8(16)	 ;  100	movqi_insn/2	[length = 1]
  79               	.LVL7:
  80 0036 00D0      		rcall MotorDir	 ;  101	call_insn/2	[length = 1]
  81               	.LVL8:
  27:main.c        **** 			 MotorSpeed(40, 100);
  82               		.loc 1 27 0
  83 0038 64E6      		ldi r22,lo8(100)	 ;  102	movqi_insn/2	[length = 1]
  84 003a 88E2      		ldi r24,lo8(40)	 ;  103	movqi_insn/2	[length = 1]
  85 003c 00D0      		rcall MotorSpeed	 ;  104	call_insn/2	[length = 1]
  86               	.LVL9:
  28:main.c        **** 			 StatusLED(RED);
  87               		.loc 1 28 0
  88 003e 82E0      		ldi r24,lo8(2)	 ;  105	movqi_insn/2	[length = 1]
  89 0040 00D0      		rcall StatusLED	 ;  106	call_insn/2	[length = 1]
  90               	.LVL10:
  91               	.L2:
  92               	.LBE9:
  13:main.c        **** 	int x = 160;
  93               		.loc 1 13 0
  94 0042 38EE      		ldi r19,lo8(-24)	 ;  299	*reload_inhi	[length = 4]
  95 0044 A32E      		mov r10,r19
  96 0046 33E0      		ldi r19,lo8(3)
  97 0048 B32E      		mov r11,r19
  98               	.LVL11:
  99               	.L3:
 100               	.LBB16:
 101               	.LBB10:
 102               	.LBB11:
 103               		.file 2 "../../libtinyasuro/inc/asuro/time.h"
   1:../../libtinyasuro/inc/asuro/time.h **** /**
   2:../../libtinyasuro/inc/asuro/time.h ****  * @file
   3:../../libtinyasuro/inc/asuro/time.h ****  *
   4:../../libtinyasuro/inc/asuro/time.h ****  * \if de
   5:../../libtinyasuro/inc/asuro/time.h ****  * Definiert die Schnittstelle für die Verwendung des Timer2 als gemeinsame
   6:../../libtinyasuro/inc/asuro/time.h ****  * Zeitbasis und Taktquelle.
   7:../../libtinyasuro/inc/asuro/time.h ****  *
   8:../../libtinyasuro/inc/asuro/time.h ****  * Es werden Funktionen definiert, die es ermöglichen, den Prozessor für einen
   9:../../libtinyasuro/inc/asuro/time.h ****  * definierten Zeitraum oder bis zum nächsten Interrupt in den Idle-Mode zu
  10:../../libtinyasuro/inc/asuro/time.h ****  * versetzen (unter Verwendung der Funktionalität aus avr/sleep.h).
  11:../../libtinyasuro/inc/asuro/time.h ****  *
  12:../../libtinyasuro/inc/asuro/time.h ****  * Außerdem wird die Möglichkeit geboten, die Taktausgabe für die
  13:../../libtinyasuro/inc/asuro/time.h ****  * IR-Schnittstelle ein- und auszuschalten.
  14:../../libtinyasuro/inc/asuro/time.h ****  *
  15:../../libtinyasuro/inc/asuro/time.h ****  * Zusätzlich besteht die Möglichkeit, eine eigene Funktion in der mit 36kHz
  16:../../libtinyasuro/inc/asuro/time.h ****  * aufgerufenen Timer2-ISR auszuführen, sofern diese Option in hooks.h aktiviert
  17:../../libtinyasuro/inc/asuro/time.h ****  * ist.
  18:../../libtinyasuro/inc/asuro/time.h ****  *
  19:../../libtinyasuro/inc/asuro/time.h ****  * @par Wichtiger Hinweis:
  20:../../libtinyasuro/inc/asuro/time.h ****  *      Für eine korrekte Funktion des Moduls müssen Interrupts global
  21:../../libtinyasuro/inc/asuro/time.h ****  *      freigeschaltet sein, Ausnahmen sind für kurze Zeitspannen zulässig,
  22:../../libtinyasuro/inc/asuro/time.h ****  *      können aber die Genauigkeit negativ beeinflussen.
  23:../../libtinyasuro/inc/asuro/time.h ****  *
  24:../../libtinyasuro/inc/asuro/time.h ****  * @par Initialisierung:
  25:../../libtinyasuro/inc/asuro/time.h ****  *      Vor der Verwendung des Moduls muss Timer2Init() aufgerufen werden, zudem
  26:../../libtinyasuro/inc/asuro/time.h ****  *      wird eine globale Interruptfreigabe benötigt.
  27:../../libtinyasuro/inc/asuro/time.h ****  *
  28:../../libtinyasuro/inc/asuro/time.h ****  * @par Genutzte Hardwareressourcen:
  29:../../libtinyasuro/inc/asuro/time.h ****  *      Module:
  30:../../libtinyasuro/inc/asuro/time.h ****  *      @li Timer2
  31:../../libtinyasuro/inc/asuro/time.h ****  *
  32:../../libtinyasuro/inc/asuro/time.h ****  *      Interruptvektoren:
  33:../../libtinyasuro/inc/asuro/time.h ****  *      @li TIMER2_OVF
  34:../../libtinyasuro/inc/asuro/time.h ****  *
  35:../../libtinyasuro/inc/asuro/time.h ****  *      I/O:
  36:../../libtinyasuro/inc/asuro/time.h ****  *      @li Port B: Pin 3 (36kHz-Träger der IR-Schnittstelle)
  37:../../libtinyasuro/inc/asuro/time.h ****  * \endif
  38:../../libtinyasuro/inc/asuro/time.h ****  *
  39:../../libtinyasuro/inc/asuro/time.h ****  * \if en
  40:../../libtinyasuro/inc/asuro/time.h ****  * Interface definitions to use timer2 as common clock source and time
  41:../../libtinyasuro/inc/asuro/time.h ****  * reference.
  42:../../libtinyasuro/inc/asuro/time.h ****  *
  43:../../libtinyasuro/inc/asuro/time.h ****  * This interface defines functions to put the microcontroller into idle mode
  44:../../libtinyasuro/inc/asuro/time.h ****  * for either a defined timespan or until the next interrupt occurs. The
  45:../../libtinyasuro/inc/asuro/time.h ****  * functionality in avr/sleep.h is used for this purpose.
  46:../../libtinyasuro/inc/asuro/time.h ****  *
  47:../../libtinyasuro/inc/asuro/time.h ****  * The carrier clock for the IR communications interface can be controlled
  48:../../libtinyasuro/inc/asuro/time.h ****  * using this interface.
  49:../../libtinyasuro/inc/asuro/time.h ****  *
  50:../../libtinyasuro/inc/asuro/time.h ****  * Timer2 is operating with a frequency of 36kHz, custom code can be executed
  51:../../libtinyasuro/inc/asuro/time.h ****  * by an ISR of timer2 if this feature is enabled in hooks.h.
  52:../../libtinyasuro/inc/asuro/time.h ****  *
  53:../../libtinyasuro/inc/asuro/time.h ****  * @par Important:
  54:../../libtinyasuro/inc/asuro/time.h ****  *      This module requires interrupts to be enabled globally. Short term
  55:../../libtinyasuro/inc/asuro/time.h ****  *      exceptions may be permittable but can have a negative effect on the
  56:../../libtinyasuro/inc/asuro/time.h ****  *      accuracy of the provided clock.
  57:../../libtinyasuro/inc/asuro/time.h ****  *
  58:../../libtinyasuro/inc/asuro/time.h ****  * @par Initialization:
  59:../../libtinyasuro/inc/asuro/time.h ****  *      Timer2Init() must be called before using this module. Interrupts must be
  60:../../libtinyasuro/inc/asuro/time.h ****  *      enabled globally.
  61:../../libtinyasuro/inc/asuro/time.h ****  *
  62:../../libtinyasuro/inc/asuro/time.h ****  * @par Hardware resources in use:
  63:../../libtinyasuro/inc/asuro/time.h ****  *      Components:
  64:../../libtinyasuro/inc/asuro/time.h ****  *      @li Timer2
  65:../../libtinyasuro/inc/asuro/time.h ****  *
  66:../../libtinyasuro/inc/asuro/time.h ****  *      Interrupt vectors:
  67:../../libtinyasuro/inc/asuro/time.h ****  *      @li TIMER2_OVF
  68:../../libtinyasuro/inc/asuro/time.h ****  *
  69:../../libtinyasuro/inc/asuro/time.h ****  *      I/O:
  70:../../libtinyasuro/inc/asuro/time.h ****  *      @li Port B: Pin 3 (36kHz carrier signal for IR communications)
  71:../../libtinyasuro/inc/asuro/time.h ****  * \endif
  72:../../libtinyasuro/inc/asuro/time.h ****  *
  73:../../libtinyasuro/inc/asuro/time.h ****  * @see hooks.h
  74:../../libtinyasuro/inc/asuro/time.h ****  *
  75:../../libtinyasuro/inc/asuro/time.h ****  * @author Markus Jung
  76:../../libtinyasuro/inc/asuro/time.h ****  *
  77:../../libtinyasuro/inc/asuro/time.h ****  * @version 23.05.2010 \n
  78:../../libtinyasuro/inc/asuro/time.h ****  *  Schnittstellendefinition entsprechend asuro.h
  79:../../libtinyasuro/inc/asuro/time.h ****  * @version 28.05.2010 \n
  80:../../libtinyasuro/inc/asuro/time.h ****  *  Zählervariable zugänglich gemacht
  81:../../libtinyasuro/inc/asuro/time.h ****  * @version 02.06.2010 \n
  82:../../libtinyasuro/inc/asuro/time.h ****  *  sleepUntilInterrupt implementiert
  83:../../libtinyasuro/inc/asuro/time.h ****  * @version 15.06.2010 \n
  84:../../libtinyasuro/inc/asuro/time.h ****  *  Doku
  85:../../libtinyasuro/inc/asuro/time.h ****  * @version 26.06.2010 \n
  86:../../libtinyasuro/inc/asuro/time.h ****  *  Alias-Makros für sleep, msleep und sleepUntilInterrupt hinzugefügt
  87:../../libtinyasuro/inc/asuro/time.h ****  *  (zwecks konsistentem Namensschema)
  88:../../libtinyasuro/inc/asuro/time.h ****  * @version 16.08.2010 \n
  89:../../libtinyasuro/inc/asuro/time.h ****  *  + Hook für Timer2ISR
  90:../../libtinyasuro/inc/asuro/time.h ****  * @version 13.09.2013 \n
  91:../../libtinyasuro/inc/asuro/time.h ****  *  English documentation
  92:../../libtinyasuro/inc/asuro/time.h ****  * @version 29.10.2013 \n
  93:../../libtinyasuro/inc/asuro/time.h ****  *  Document interrupt safety issues of TIMER2_CLOCK_OUT_ENABLE() and
  94:../../libtinyasuro/inc/asuro/time.h ****  *  TIMER2_CLOCK_OUT_DISABLE()
  95:../../libtinyasuro/inc/asuro/time.h ****  */
  96:../../libtinyasuro/inc/asuro/time.h **** /*
  97:../../libtinyasuro/inc/asuro/time.h ****  * The contents of this file are subject to the terms of the Common Development
  98:../../libtinyasuro/inc/asuro/time.h ****  * and Distribution License Version 1.0 (the License).
  99:../../libtinyasuro/inc/asuro/time.h ****  * You may not use this file except in compliance with the License.
 100:../../libtinyasuro/inc/asuro/time.h ****  *
 101:../../libtinyasuro/inc/asuro/time.h ****  * If not included, you can obtain a copy of the License at
 102:../../libtinyasuro/inc/asuro/time.h ****  * http://www.sun.com/cddl/cddl.html
 103:../../libtinyasuro/inc/asuro/time.h ****  *
 104:../../libtinyasuro/inc/asuro/time.h ****  * When distributing Covered Code, include this CDDL Header Notice in each file
 105:../../libtinyasuro/inc/asuro/time.h ****  * and include the provided License file.
 106:../../libtinyasuro/inc/asuro/time.h ****  */
 107:../../libtinyasuro/inc/asuro/time.h **** 
 108:../../libtinyasuro/inc/asuro/time.h **** #ifndef TIME_H_
 109:../../libtinyasuro/inc/asuro/time.h **** #define TIME_H_
 110:../../libtinyasuro/inc/asuro/time.h **** 
 111:../../libtinyasuro/inc/asuro/time.h **** #include <stdbool.h>
 112:../../libtinyasuro/inc/asuro/time.h **** #include <stdint.h>
 113:../../libtinyasuro/inc/asuro/time.h **** #include "hooks.h"
 114:../../libtinyasuro/inc/asuro/time.h **** #include "../util/misc.h"
 115:../../libtinyasuro/inc/asuro/time.h **** 
 116:../../libtinyasuro/inc/asuro/time.h **** #ifdef __DOXYGEN__
 117:../../libtinyasuro/inc/asuro/time.h **** /** \if de
 118:../../libtinyasuro/inc/asuro/time.h ****  * Alias-Makro für sleep().
 119:../../libtinyasuro/inc/asuro/time.h ****  * \endif
 120:../../libtinyasuro/inc/asuro/time.h ****  *
 121:../../libtinyasuro/inc/asuro/time.h ****  * \if en
 122:../../libtinyasuro/inc/asuro/time.h ****  * Alias macro for sleep().
 123:../../libtinyasuro/inc/asuro/time.h ****  * \endif
 124:../../libtinyasuro/inc/asuro/time.h ****  */
 125:../../libtinyasuro/inc/asuro/time.h **** #define Sleep
 126:../../libtinyasuro/inc/asuro/time.h **** /** \if de
 127:../../libtinyasuro/inc/asuro/time.h ****  * Alias-Makro für msleep().
 128:../../libtinyasuro/inc/asuro/time.h ****  * \endif
 129:../../libtinyasuro/inc/asuro/time.h ****  *
 130:../../libtinyasuro/inc/asuro/time.h ****  * \if en
 131:../../libtinyasuro/inc/asuro/time.h ****  * Alias macro for msleep().
 132:../../libtinyasuro/inc/asuro/time.h ****  * \endif
 133:../../libtinyasuro/inc/asuro/time.h ****  */
 134:../../libtinyasuro/inc/asuro/time.h **** #define Msleep
 135:../../libtinyasuro/inc/asuro/time.h **** /** \if de
 136:../../libtinyasuro/inc/asuro/time.h ****  * Alias-Makro für sleepUntilInterrupt().
 137:../../libtinyasuro/inc/asuro/time.h ****  * \endif
 138:../../libtinyasuro/inc/asuro/time.h ****  *
 139:../../libtinyasuro/inc/asuro/time.h ****  * \if en
 140:../../libtinyasuro/inc/asuro/time.h ****  * Alias macro for sleepUntilInterrupt().
 141:../../libtinyasuro/inc/asuro/time.h ****  * \endif
 142:../../libtinyasuro/inc/asuro/time.h ****  */
 143:../../libtinyasuro/inc/asuro/time.h **** #define SleepUntilInterrupt
 144:../../libtinyasuro/inc/asuro/time.h **** #else
 145:../../libtinyasuro/inc/asuro/time.h **** #define Sleep               sleep
 146:../../libtinyasuro/inc/asuro/time.h **** #define Msleep              msleep
 147:../../libtinyasuro/inc/asuro/time.h **** #define SleepUntilInterrupt sleepUntilInterrupt
 148:../../libtinyasuro/inc/asuro/time.h **** #endif
 149:../../libtinyasuro/inc/asuro/time.h **** 
 150:../../libtinyasuro/inc/asuro/time.h **** /**
 151:../../libtinyasuro/inc/asuro/time.h ****  * \if de
 152:../../libtinyasuro/inc/asuro/time.h ****  * Eine Zählvariable die im 36kHz-Takt (um eins) inkrementiert wird.
 153:../../libtinyasuro/inc/asuro/time.h ****  * \endif
 154:../../libtinyasuro/inc/asuro/time.h ****  *
 155:../../libtinyasuro/inc/asuro/time.h ****  * \if en
 156:../../libtinyasuro/inc/asuro/time.h ****  * A counting variable incremented from the 36kHz clock.
 157:../../libtinyasuro/inc/asuro/time.h ****  * \endif
 158:../../libtinyasuro/inc/asuro/time.h ****  */
 159:../../libtinyasuro/inc/asuro/time.h **** extern volatile uint8_t tick36kHz; // counts from 0 to 255
 160:../../libtinyasuro/inc/asuro/time.h **** 
 161:../../libtinyasuro/inc/asuro/time.h **** #ifdef __DOXYGEN__
 162:../../libtinyasuro/inc/asuro/time.h **** /**
 163:../../libtinyasuro/inc/asuro/time.h ****  * \if de
 164:../../libtinyasuro/inc/asuro/time.h ****  * Bietet die Möglichkeit, eine eigene Funktion bei jedem Aufruf der Timer-ISR
 165:../../libtinyasuro/inc/asuro/time.h ****  * auszuführen. Die interne Funktionalität bleibt dabei erhalten.
 166:../../libtinyasuro/inc/asuro/time.h ****  *
 167:../../libtinyasuro/inc/asuro/time.h ****  * Da die Timer-ISR mit einer Frequenz von 36kHz aufgerufen wird, sollte diese
 168:../../libtinyasuro/inc/asuro/time.h ****  * Funktion möglichst kurz sein.
 169:../../libtinyasuro/inc/asuro/time.h ****  *
 170:../../libtinyasuro/inc/asuro/time.h ****  * Der Aufruf erfolgt aus dem Kontext eines Interrupts!
 171:../../libtinyasuro/inc/asuro/time.h ****  *
 172:../../libtinyasuro/inc/asuro/time.h ****  * Ist (Timer2ISRHook == NULL), findet kein Aufruf statt.
 173:../../libtinyasuro/inc/asuro/time.h ****  *
 174:../../libtinyasuro/inc/asuro/time.h ****  * Diese Funktionalität steht nicht zur Verfügung, wenn TIMER2_ISR_HOOK_ENABLE
 175:../../libtinyasuro/inc/asuro/time.h ****  * deaktiviert ist.
 176:../../libtinyasuro/inc/asuro/time.h ****  * \endif
 177:../../libtinyasuro/inc/asuro/time.h ****  *
 178:../../libtinyasuro/inc/asuro/time.h ****  * \if en
 179:../../libtinyasuro/inc/asuro/time.h ****  * Offers the ability to execute a custom function in addition to the internal
 180:../../libtinyasuro/inc/asuro/time.h ****  * code of the timer ISR.
 181:../../libtinyasuro/inc/asuro/time.h ****  *
 182:../../libtinyasuro/inc/asuro/time.h ****  * Since the ISR will be executed with a frequency of 36kHz, the called function
 183:../../libtinyasuro/inc/asuro/time.h ****  * should be as short as possible.
 184:../../libtinyasuro/inc/asuro/time.h ****  *
 185:../../libtinyasuro/inc/asuro/time.h ****  * The function will be called from an interrupt context!
 186:../../libtinyasuro/inc/asuro/time.h ****  *
 187:../../libtinyasuro/inc/asuro/time.h ****  * No function call will be executed if (Timer2ISRHook == NULL).
 188:../../libtinyasuro/inc/asuro/time.h ****  *
 189:../../libtinyasuro/inc/asuro/time.h ****  * The timer hook feature is not available if TIMER2_ISR_HOOK_ENABLE has been
 190:../../libtinyasuro/inc/asuro/time.h ****  * disabled.
 191:../../libtinyasuro/inc/asuro/time.h ****  * \endif
 192:../../libtinyasuro/inc/asuro/time.h ****  */
 193:../../libtinyasuro/inc/asuro/time.h **** extern ISRHookFunc_t *Timer2ISRHook;
 194:../../libtinyasuro/inc/asuro/time.h **** #else  // !__DOXYGEN__
 195:../../libtinyasuro/inc/asuro/time.h **** #if TIMER2_ISR_HOOK_ENABLE
 196:../../libtinyasuro/inc/asuro/time.h **** extern ISRHookFunc_t *Timer2ISRHook;
 197:../../libtinyasuro/inc/asuro/time.h **** #endif
 198:../../libtinyasuro/inc/asuro/time.h **** #endif
 199:../../libtinyasuro/inc/asuro/time.h **** 
 200:../../libtinyasuro/inc/asuro/time.h **** /**
 201:../../libtinyasuro/inc/asuro/time.h ****  * \if de
 202:../../libtinyasuro/inc/asuro/time.h ****  * Initialisiert das Modul und den als Zeitbasis und Taktgenerator für die
 203:../../libtinyasuro/inc/asuro/time.h ****  * Infrarotschnittstelle verwendeten Timer2.
 204:../../libtinyasuro/inc/asuro/time.h ****  *
 205:../../libtinyasuro/inc/asuro/time.h ****  * Nach der Initialisierung ist die Taktausgabe für die Infrarotschnittstelle
 206:../../libtinyasuro/inc/asuro/time.h ****  * deaktiviert.
 207:../../libtinyasuro/inc/asuro/time.h ****  * \endif
 208:../../libtinyasuro/inc/asuro/time.h ****  *
 209:../../libtinyasuro/inc/asuro/time.h ****  * \if en
 210:../../libtinyasuro/inc/asuro/time.h ****  * Initializes the module and timer2 which is used as time reference and clock
 211:../../libtinyasuro/inc/asuro/time.h ****  * source for the IR communications interface.
 212:../../libtinyasuro/inc/asuro/time.h ****  *
 213:../../libtinyasuro/inc/asuro/time.h ****  * The clock output for the IR interface will be in a disabled state after the
 214:../../libtinyasuro/inc/asuro/time.h ****  * initialization has been completed.
 215:../../libtinyasuro/inc/asuro/time.h ****  * \endif
 216:../../libtinyasuro/inc/asuro/time.h ****  */
 217:../../libtinyasuro/inc/asuro/time.h **** extern void Timer2Init(void);
 218:../../libtinyasuro/inc/asuro/time.h **** 
 219:../../libtinyasuro/inc/asuro/time.h **** /**
 220:../../libtinyasuro/inc/asuro/time.h ****  * \if de
 221:../../libtinyasuro/inc/asuro/time.h ****  * Aktiviert die Ausgabe des 36kHz-Signals für die Infrarotschnittstelle.
 222:../../libtinyasuro/inc/asuro/time.h ****  *
 223:../../libtinyasuro/inc/asuro/time.h ****  * @par Wichtiger Hinweis:
 224:../../libtinyasuro/inc/asuro/time.h ****  * Dieses Makro ist nur eingeschänkt interruptfest. Es darf nicht "parallel" zu
 225:../../libtinyasuro/inc/asuro/time.h ****  * TIMER2_CLOCK_OUT_DISABLE() ausgeführt werden.
 226:../../libtinyasuro/inc/asuro/time.h ****  * \endif
 227:../../libtinyasuro/inc/asuro/time.h ****  *
 228:../../libtinyasuro/inc/asuro/time.h ****  * \if en
 229:../../libtinyasuro/inc/asuro/time.h ****  * Enables the 36kHz carrier signal for the IR communications interface.
 230:../../libtinyasuro/inc/asuro/time.h ****  *
 231:../../libtinyasuro/inc/asuro/time.h ****  * @par Important:
 232:../../libtinyasuro/inc/asuro/time.h ****  * This macro is interrupt-safe except for one restriction. It must not be
 233:../../libtinyasuro/inc/asuro/time.h ****  * executed in parallel to TIMER2_CLOCK_OUT_DISABLE().
 234:../../libtinyasuro/inc/asuro/time.h ****  * \endif
 235:../../libtinyasuro/inc/asuro/time.h ****  */
 236:../../libtinyasuro/inc/asuro/time.h **** #ifdef __DOXYGEN__
 237:../../libtinyasuro/inc/asuro/time.h **** #define TIMER2_CLOCK_OUT_ENABLE()
 238:../../libtinyasuro/inc/asuro/time.h **** #else
 239:../../libtinyasuro/inc/asuro/time.h **** #define TIMER2_CLOCK_OUT_ENABLE() \
 240:../../libtinyasuro/inc/asuro/time.h ****     do { /* Fast PWM, BOTTOM: Clear, CompMatch: Set */ \
 241:../../libtinyasuro/inc/asuro/time.h ****         TCCR2 |= (1 << WGM20) | (1 << WGM21) | (1 << COM20) | (1 << COM21); \
 242:../../libtinyasuro/inc/asuro/time.h ****     } while (false)
 243:../../libtinyasuro/inc/asuro/time.h **** #endif
 244:../../libtinyasuro/inc/asuro/time.h **** 
 245:../../libtinyasuro/inc/asuro/time.h **** /**
 246:../../libtinyasuro/inc/asuro/time.h ****  * \if de
 247:../../libtinyasuro/inc/asuro/time.h ****  * Deaktiviert die Ausgabe des 36kHz-Signals für die Infrarotschnittstelle.
 248:../../libtinyasuro/inc/asuro/time.h ****  *
 249:../../libtinyasuro/inc/asuro/time.h ****  * @par Wichtiger Hinweis:
 250:../../libtinyasuro/inc/asuro/time.h ****  * Dieses Makro ist nur eingeschränkt interruptfest. Es darf nicht "parallel"
 251:../../libtinyasuro/inc/asuro/time.h ****  * zu TIMER2_CLOCK_OUT_ENABLE() ausgeführt werden.
 252:../../libtinyasuro/inc/asuro/time.h ****  * \endif
 253:../../libtinyasuro/inc/asuro/time.h ****  *
 254:../../libtinyasuro/inc/asuro/time.h ****  * \if en
 255:../../libtinyasuro/inc/asuro/time.h ****  * Disables the 36kHz carrier signal for the IR communications interface.
 256:../../libtinyasuro/inc/asuro/time.h ****  *
 257:../../libtinyasuro/inc/asuro/time.h ****  * @par Important:
 258:../../libtinyasuro/inc/asuro/time.h ****  * This macro is interrupt-safe except for one restriction. It must not be
 259:../../libtinyasuro/inc/asuro/time.h ****  * executed in parallel to TIMER2_CLOCK_OUT_ENABLE().
 260:../../libtinyasuro/inc/asuro/time.h ****  * \endif
 261:../../libtinyasuro/inc/asuro/time.h ****  */
 262:../../libtinyasuro/inc/asuro/time.h **** #ifdef __DOXYGEN__
 263:../../libtinyasuro/inc/asuro/time.h **** #define TIMER2_CLOCK_OUT_DISABLE()
 264:../../libtinyasuro/inc/asuro/time.h **** #else
 265:../../libtinyasuro/inc/asuro/time.h **** #define TIMER2_CLOCK_OUT_DISABLE() \
 266:../../libtinyasuro/inc/asuro/time.h ****     do { /* PWM off */ \
 267:../../libtinyasuro/inc/asuro/time.h ****         TCCR2 &= ~((1 << WGM20) | (1 << WGM21) | (1 << COM20) | (1 << COM21)); \
 268:../../libtinyasuro/inc/asuro/time.h ****     } while (false)
 269:../../libtinyasuro/inc/asuro/time.h **** #endif
 270:../../libtinyasuro/inc/asuro/time.h **** 
 271:../../libtinyasuro/inc/asuro/time.h **** /**
 272:../../libtinyasuro/inc/asuro/time.h ****  * \if de
 273:../../libtinyasuro/inc/asuro/time.h ****  * Hält den Programmfluss für die vorgegebene Anzahl 36kHz-Takte an und schickt
 274:../../libtinyasuro/inc/asuro/time.h ****  * den Prozessor währendessen in den Idle-Mode.
 275:../../libtinyasuro/inc/asuro/time.h ****  *
 276:../../libtinyasuro/inc/asuro/time.h ****  * Alle Interrupts bleiben aktiv und werden ausgeführt, ledliglich der
 277:../../libtinyasuro/inc/asuro/time.h ****  * aufrufende Programmpfad wird unterbrochen.
 278:../../libtinyasuro/inc/asuro/time.h ****  *
 279:../../libtinyasuro/inc/asuro/time.h ****  * Wenn diese Funktion aufgerufen wird, geht sie davon aus, dass Interrupts
 280:../../libtinyasuro/inc/asuro/time.h ****  * global freigeschaltet sind - wenn nicht findet die globale Interruptfreigabe
 281:../../libtinyasuro/inc/asuro/time.h ****  * vor Eintritt in den Idle-Mode statt.
 282:../../libtinyasuro/inc/asuro/time.h ****  *
 283:../../libtinyasuro/inc/asuro/time.h ****  * @param timer36kHz_ticks die Anzahl der 36kHz-Takte die der Prozessor
 284:../../libtinyasuro/inc/asuro/time.h ****  *                         "schlafen" soll
 285:../../libtinyasuro/inc/asuro/time.h ****  * \endif
 286:../../libtinyasuro/inc/asuro/time.h ****  *
 287:../../libtinyasuro/inc/asuro/time.h ****  * \if en
 288:../../libtinyasuro/inc/asuro/time.h ****  * Delays the execution for the specified amount of time, measured in 36kHz
 289:../../libtinyasuro/inc/asuro/time.h ****  * ticks. The microcontroller will halted (idle mode) during this time.
 290:../../libtinyasuro/inc/asuro/time.h ****  *
 291:../../libtinyasuro/inc/asuro/time.h ****  * All interrupt requests remain active and will be executed, the calling
 292:../../libtinyasuro/inc/asuro/time.h ****  * function itself remains halted.
 293:../../libtinyasuro/inc/asuro/time.h ****  *
 294:../../libtinyasuro/inc/asuro/time.h ****  * This function expects interrupts to be globally enabled if it gets called.
 295:../../libtinyasuro/inc/asuro/time.h ****  * If not, the global interrupt enable bit will be set before entering the sleep
 296:../../libtinyasuro/inc/asuro/time.h ****  * mode and remain in this state after the function returns.
 297:../../libtinyasuro/inc/asuro/time.h ****  *
 298:../../libtinyasuro/inc/asuro/time.h ****  * @param timer36kHz_ticks the number of 36kHz ticks the microcontroller will
 299:../../libtinyasuro/inc/asuro/time.h ****  *                         be halted.
 300:../../libtinyasuro/inc/asuro/time.h ****  * \endif
 301:../../libtinyasuro/inc/asuro/time.h ****  */
 302:../../libtinyasuro/inc/asuro/time.h **** extern void sleep(uint8_t timer36kHz_ticks);
 303:../../libtinyasuro/inc/asuro/time.h **** /**
 304:../../libtinyasuro/inc/asuro/time.h ****  * \if de
 305:../../libtinyasuro/inc/asuro/time.h ****  * Schickt den Prozessor in den Idle-Mode und kehrt zurück, nachdem ein
 306:../../libtinyasuro/inc/asuro/time.h ****  * Interrupt ausgelöst wurde.
 307:../../libtinyasuro/inc/asuro/time.h ****  *
 308:../../libtinyasuro/inc/asuro/time.h ****  * Wenn diese Funktion aufgerufen wird, geht sie davon aus, dass Interrupts
 309:../../libtinyasuro/inc/asuro/time.h ****  * global freigeschaltet sind - wenn nicht findet die globale Interruptfreigabe
 310:../../libtinyasuro/inc/asuro/time.h ****  * vor Eintritt in den Idle-Mode statt.
 311:../../libtinyasuro/inc/asuro/time.h ****  * \endif
 312:../../libtinyasuro/inc/asuro/time.h ****  *
 313:../../libtinyasuro/inc/asuro/time.h ****  * \if en
 314:../../libtinyasuro/inc/asuro/time.h ****  * Puts the microcontroller into idle mode until the next interrupt occurs.
 315:../../libtinyasuro/inc/asuro/time.h ****  *
 316:../../libtinyasuro/inc/asuro/time.h ****  * This function expects interrupts to be globally enabled if it gets called.
 317:../../libtinyasuro/inc/asuro/time.h ****  * If not, the global interrupt enable bit will be set before entering the sleep
 318:../../libtinyasuro/inc/asuro/time.h ****  * mode and remain in this state after the function returns.
 319:../../libtinyasuro/inc/asuro/time.h ****  * \endif
 320:../../libtinyasuro/inc/asuro/time.h ****  */
 321:../../libtinyasuro/inc/asuro/time.h **** extern void sleepUntilInterrupt(void);
 322:../../libtinyasuro/inc/asuro/time.h **** 
 323:../../libtinyasuro/inc/asuro/time.h **** /**
 324:../../libtinyasuro/inc/asuro/time.h ****  * \if de
 325:../../libtinyasuro/inc/asuro/time.h ****  * Verhält sich wie sleep(), verwendet als Zeitbasis aber Millisekunden
 326:../../libtinyasuro/inc/asuro/time.h ****  *
 327:../../libtinyasuro/inc/asuro/time.h ****  * @param ms die Anzahl der Millisekunden die der Prozessor "schlafend"
 328:../../libtinyasuro/inc/asuro/time.h ****  *           verbringen soll
 329:../../libtinyasuro/inc/asuro/time.h ****  * \endif
 330:../../libtinyasuro/inc/asuro/time.h ****  *
 331:../../libtinyasuro/inc/asuro/time.h ****  * \if en
 332:../../libtinyasuro/inc/asuro/time.h ****  * Behaves like sleep() but uses milliseconds as timebase.
 333:../../libtinyasuro/inc/asuro/time.h ****  *
 334:../../libtinyasuro/inc/asuro/time.h ****  * @param ms the time the microcontroller will be halted, measured in
 335:../../libtinyasuro/inc/asuro/time.h ****  *           milliseconds
 336:../../libtinyasuro/inc/asuro/time.h ****  * \endif
 337:../../libtinyasuro/inc/asuro/time.h ****  */
 338:../../libtinyasuro/inc/asuro/time.h **** #ifdef __DOXYGEN__
 339:../../libtinyasuro/inc/asuro/time.h **** void msleep(uint16_t ms);
 340:../../libtinyasuro/inc/asuro/time.h **** #else
 341:../../libtinyasuro/inc/asuro/time.h **** static ALWAYS_INLINE void msleep(uint16_t ms);
 342:../../libtinyasuro/inc/asuro/time.h **** #endif
 343:../../libtinyasuro/inc/asuro/time.h **** 
 344:../../libtinyasuro/inc/asuro/time.h **** void msleep(uint16_t ms) {
 345:../../libtinyasuro/inc/asuro/time.h ****     for (; ms > 0; ms--) {
 346:../../libtinyasuro/inc/asuro/time.h ****         sleep(36);
 104               		.loc 2 346 0
 105 004a 84E2      		ldi r24,lo8(36)	 ;  112	movqi_insn/2	[length = 1]
 106 004c 00D0      		rcall sleep	 ;  113	call_insn/2	[length = 1]
 107               	.LVL12:
 108 004e 81E0      		ldi r24,1	 ;  117	addhi3_clobber/3	[length = 3]
 109 0050 A81A      		sub r10,r24
 110 0052 B108      		sbc r11,__zero_reg__
 111               	.LVL13:
 345:../../libtinyasuro/inc/asuro/time.h ****         sleep(36);
 112               		.loc 2 345 0
 113 0054 01F4      		brne .L3	 ;  120	branch	[length = 1]
 114               	.LBE11:
 115               	.LBE10:
  29:main.c        **** 		}
  30:main.c        **** 		msleep(1000);
  31:main.c        **** 		uint16_t data[] = {0,0};
 116               		.loc 1 31 0
 117 0056 1A82      		std Y+2,__zero_reg__	 ;  254	*movhi/4	[length = 2]
 118 0058 1982      		std Y+1,__zero_reg__
 119 005a 1C82      		std Y+4,__zero_reg__	 ;  255	*movhi/4	[length = 2]
 120 005c 1B82      		std Y+3,__zero_reg__
 121               	.LVL14:
 122               	.L21:
  32:main.c        **** 		LineData(data);
  33:main.c        **** 		while (((data[LEFT] > 40) || (data[RIGHT] > 40)) && (x > 10))
  34:main.c        **** 		{	
  35:main.c        **** 			MotorSpeed(x, y);
  36:main.c        **** 			x -= 5;
  37:main.c        **** 			y -= 5;
  38:main.c        **** 			LineData(data);
 123               		.loc 1 38 0
 124 005e CE01      		movw r24,r28	 ;  281	*movhi/1	[length = 1]
 125 0060 0196      		adiw r24,1	 ;  136	*addhi3/3	[length = 1]
 126 0062 00D0      		rcall LineData	 ;  137	call_insn/2	[length = 1]
 127               	.LVL15:
  33:main.c        **** 		{	
 128               		.loc 1 33 0
 129 0064 8981      		ldd r24,Y+1	 ;  142	*movhi/3	[length = 2]
 130 0066 9A81      		ldd r25,Y+2
 131 0068 8997      		sbiw r24,41	 ;  143	*cmphi/6	[length = 1]
 132 006a 00F4      		brsh .L5	 ;  144	branch	[length = 1]
  33:main.c        **** 		{	
 133               		.loc 1 33 0 is_stmt 0 discriminator 2
 134 006c 8B81      		ldd r24,Y+3	 ;  146	*movhi/3	[length = 2]
 135 006e 9C81      		ldd r25,Y+4
 136 0070 8997      		sbiw r24,41	 ;  147	*cmphi/6	[length = 1]
 137 0072 00F0      		brlo .L8	 ;  148	branch	[length = 1]
 138               	.L5:
  33:main.c        **** 		{	
 139               		.loc 1 33 0 discriminator 3
 140 0074 0B30      		cpi r16,11	 ;  152	*cmphi/6	[length = 2]
 141 0076 1105      		cpc r17,__zero_reg__
 142 0078 04F0      		brlt .L8	 ;  153	branch	[length = 1]
  35:main.c        **** 			x -= 5;
 143               		.loc 1 35 0 is_stmt 1
 144 007a 6C2D      		mov r22,r12	 ;  129	movqi_insn/1	[length = 1]
 145 007c 802F      		mov r24,r16	 ;  130	movqi_insn/1	[length = 1]
 146 007e 00D0      		rcall MotorSpeed	 ;  131	call_insn/2	[length = 1]
 147               	.LVL16:
  36:main.c        **** 			y -= 5;
 148               		.loc 1 36 0
 149 0080 0550      		subi r16,5	 ;  132	addhi3_clobber/2	[length = 2]
 150 0082 1109      		sbc r17,__zero_reg__
 151               	.LVL17:
  37:main.c        **** 			LineData(data);
 152               		.loc 1 37 0
 153 0084 85E0      		ldi r24,5	 ;  134	addhi3_clobber/3	[length = 3]
 154 0086 C81A      		sub r12,r24
 155 0088 D108      		sbc r13,__zero_reg__
 156               	.LVL18:
 157 008a 00C0      		rjmp .L21	 ;  303	jump	[length = 1]
 158               	.LVL19:
 159               	.L12:
  39:main.c        **** 		} 
  40:main.c        **** 		while ((data[LEFT] > 100) || (data[RIGHT] > 100))
  41:main.c        **** 		{	
  42:main.c        **** 			MotorSpeed(0, 0);
 160               		.loc 1 42 0
 161 008c 60E0      		ldi r22,0	 ;  159	movqi_insn/1	[length = 1]
 162 008e 80E0      		ldi r24,0	 ;  160	movqi_insn/1	[length = 1]
 163 0090 00D0      		rcall MotorSpeed	 ;  161	call_insn/2	[length = 1]
 164               	.LVL20:
  43:main.c        **** 			if (status) {
 165               		.loc 1 43 0
 166 0092 EF28      		or r14,r15	 ;  162	*cmphi/2	[length = 1]
 167 0094 01F0      		breq .L9	 ;  163	branch	[length = 1]
  44:main.c        **** 				BackLED(ON, OFF);
 168               		.loc 1 44 0
 169 0096 60E0      		ldi r22,0	 ;  165	movqi_insn/1	[length = 1]
 170 0098 81E0      		ldi r24,lo8(1)	 ;  166	movqi_insn/2	[length = 1]
 171 009a 00D0      		rcall BackLED	 ;  167	call_insn/2	[length = 1]
 172               	.LVL21:
  45:main.c        **** 				status = 0;
 173               		.loc 1 45 0
 174 009c E12C      		mov r14,__zero_reg__	 ;  262	*movhi/2	[length = 2]
 175 009e F12C      		mov r15,__zero_reg__
 176               	.LVL22:
 177               	.L10:
  46:main.c        **** 			} else {
  47:main.c        **** 				BackLED(OFF, ON);
  48:main.c        **** 				status = 1;
 178               		.loc 1 48 0
 179 00a0 94EF      		ldi r25,lo8(-12)	 ;  297	*reload_inhi	[length = 4]
 180 00a2 A92E      		mov r10,r25
 181 00a4 BB24      		clr r11
 182 00a6 B394      		inc r11
 183               	.LVL23:
 184               	.L11:
 185               	.LBB12:
 186               	.LBB13:
 187               		.loc 2 346 0
 188 00a8 84E2      		ldi r24,lo8(36)	 ;  184	movqi_insn/2	[length = 1]
 189 00aa 00D0      		rcall sleep	 ;  185	call_insn/2	[length = 1]
 190               	.LVL24:
 191 00ac 81E0      		ldi r24,1	 ;  189	addhi3_clobber/3	[length = 3]
 192 00ae A81A      		sub r10,r24
 193 00b0 B108      		sbc r11,__zero_reg__
 194               	.LVL25:
 345:../../libtinyasuro/inc/asuro/time.h ****         sleep(36);
 195               		.loc 2 345 0
 196 00b2 01F4      		brne .L11	 ;  192	branch	[length = 1]
 197               	.LBE13:
 198               	.LBE12:
  49:main.c        **** 			}
  50:main.c        **** 			msleep(500);
  51:main.c        **** 			LineData(data);
 199               		.loc 1 51 0
 200 00b4 CE01      		movw r24,r28	 ;  282	*movhi/1	[length = 1]
 201 00b6 0196      		adiw r24,1	 ;  194	*addhi3/3	[length = 1]
 202 00b8 00D0      		rcall LineData	 ;  195	call_insn/2	[length = 1]
 203               	.LVL26:
 204               	.L8:
  40:main.c        **** 		{	
 205               		.loc 1 40 0
 206 00ba 8981      		ldd r24,Y+1	 ;  200	*movhi/3	[length = 2]
 207 00bc 9A81      		ldd r25,Y+2
 208 00be 8536      		cpi r24,101	 ;  201	*cmphi/6	[length = 2]
 209 00c0 9105      		cpc r25,__zero_reg__
 210 00c2 00F0      		brlo .L23	 ;  202	branch	[length = 1]
 211 00c4 00C0      		rjmp .L12	 ;  307	jump	[length = 1]
 212               	.L9:
  47:main.c        **** 				status = 1;
 213               		.loc 1 47 0
 214 00c6 61E0      		ldi r22,lo8(1)	 ;  173	movqi_insn/2	[length = 1]
 215 00c8 80E0      		ldi r24,0	 ;  174	movqi_insn/1	[length = 1]
 216 00ca 00D0      		rcall BackLED	 ;  175	call_insn/2	[length = 1]
 217               	.LVL27:
  48:main.c        **** 			}
 218               		.loc 1 48 0
 219 00cc EE24      		clr r14	 ;  298	*reload_inhi	[length = 3]
 220 00ce E394      		inc r14
 221 00d0 F12C      		mov r15,__zero_reg__
 222 00d2 00C0      		rjmp .L10	 ;  309	jump	[length = 1]
 223               	.LVL28:
 224               	.L23:
  40:main.c        **** 		{	
 225               		.loc 1 40 0 discriminator 1
 226 00d4 8B81      		ldd r24,Y+3	 ;  204	*movhi/3	[length = 2]
 227 00d6 9C81      		ldd r25,Y+4
 228 00d8 8536      		cpi r24,101	 ;  205	*cmphi/6	[length = 2]
 229 00da 9105      		cpc r25,__zero_reg__
 230 00dc 00F4      		brsh .L12	 ;  206	branch	[length = 1]
  52:main.c        **** 		} 
  53:main.c        **** 		StatusLED(GREEN);
 231               		.loc 1 53 0
 232 00de 81E0      		ldi r24,lo8(1)	 ;  208	movqi_insn/2	[length = 1]
 233 00e0 00D0      		rcall StatusLED	 ;  209	call_insn/2	[length = 1]
 234               	.LVL29:
  54:main.c        **** 		BackLED(OFF, OFF);
 235               		.loc 1 54 0
 236 00e2 60E0      		ldi r22,0	 ;  210	movqi_insn/1	[length = 1]
 237 00e4 80E0      		ldi r24,0	 ;  211	movqi_insn/1	[length = 1]
 238 00e6 00D0      		rcall BackLED	 ;  212	call_insn/2	[length = 1]
 239               	.LVL30:
 240 00e8 84EF      		ldi r24,lo8(-12)	 ;  296	*reload_inhi	[length = 4]
 241 00ea A82E      		mov r10,r24
 242 00ec BB24      		clr r11
 243 00ee B394      		inc r11
 244               	.LVL31:
 245               	.L13:
 246               	.LBB14:
 247               	.LBB15:
 248               		.loc 2 346 0
 249 00f0 84E2      		ldi r24,lo8(36)	 ;  217	movqi_insn/2	[length = 1]
 250 00f2 00D0      		rcall sleep	 ;  218	call_insn/2	[length = 1]
 251               	.LVL32:
 252 00f4 81E0      		ldi r24,1	 ;  222	addhi3_clobber/3	[length = 3]
 253 00f6 A81A      		sub r10,r24
 254 00f8 B108      		sbc r11,__zero_reg__
 255               	.LVL33:
 345:../../libtinyasuro/inc/asuro/time.h ****         sleep(36);
 256               		.loc 2 345 0
 257 00fa 01F4      		brne .L13	 ;  225	branch	[length = 1]
 258 00fc 00C0      		rjmp .L14	 ;  312	jump	[length = 1]
 259               	.LBE15:
 260               	.LBE14:
 261               	.LBE16:
 262               		.cfi_endproc
 263               	.LFE2:
 265               		.text
 266               	.Letext0:
 267               		.file 3 "/usr/lib/avr/include/stdint.h"
 268               		.file 4 "../../libtinyasuro/inc/asuro/motor.h"
 269               		.file 5 "../../libtinyasuro/inc/asuro/led.h"
 270               		.file 6 "../../libtinyasuro/inc/asuro/sensors.h"
 271               		.file 7 "../../libtinyasuro/inc/asuro/switches.h"
 272               		.file 8 "../../libtinyasuro/inc/asuro/asuro.h"
DEFINED SYMBOLS
                            *ABS*:0000000000000000 main.c
     /tmp/cc1dCLC1.s:2      *ABS*:000000000000003e __SP_H__
     /tmp/cc1dCLC1.s:3      *ABS*:000000000000003d __SP_L__
     /tmp/cc1dCLC1.s:4      *ABS*:000000000000003f __SREG__
     /tmp/cc1dCLC1.s:5      *ABS*:0000000000000000 __tmp_reg__
     /tmp/cc1dCLC1.s:6      *ABS*:0000000000000001 __zero_reg__
     /tmp/cc1dCLC1.s:13     .text.startup.main:0000000000000000 main

UNDEFINED SYMBOLS
Init
PollSwitch
MotorDir
MotorSpeed
StatusLED
sleep
LineData
BackLED
