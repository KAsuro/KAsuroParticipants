   1               		.file	"main.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   7               		.text
   8               	.Ltext0:
   9               		.cfi_sections	.debug_frame
  10               		.section	.text.stopAsuro,"ax",@progbits
  11               	.global	stopAsuro
  13               	stopAsuro:
  14               	.LFB3:
  15               		.file 1 "helpers.h"
   1:helpers.h     **** #include <stdio.h>
   2:helpers.h     **** 
   3:helpers.h     **** void stopAsuro(int pause) 
   4:helpers.h     **** {
  16               		.loc 1 4 0
  17               		.cfi_startproc
  18               	.LVL0:
  19 0000 CF93      		push r28	 ;  45	pushqi1/1	[length = 1]
  20               	.LCFI0:
  21               		.cfi_def_cfa_offset 3
  22               		.cfi_offset 28, -2
  23 0002 DF93      		push r29	 ;  46	pushqi1/1	[length = 1]
  24               	.LCFI1:
  25               		.cfi_def_cfa_offset 4
  26               		.cfi_offset 29, -3
  27               	/* prologue: function */
  28               	/* frame size = 0 */
  29               	/* stack size = 2 */
  30               	.L__stack_usage = 2
  31 0004 EC01      		movw r28,r24	 ;  2	*movhi/1	[length = 1]
   5:helpers.h     **** 	MotorSpeed(0, 0);
  32               		.loc 1 5 0
  33 0006 60E0      		ldi r22,0	 ;  6	movqi_insn/1	[length = 1]
  34 0008 80E0      		ldi r24,0	 ;  7	movqi_insn/1	[length = 1]
  35               	.LVL1:
  36 000a 00D0      		rcall MotorSpeed	 ;  8	call_insn/2	[length = 1]
  37               	.LVL2:
   6:helpers.h     **** 	if (pause > 0)
  38               		.loc 1 6 0
  39 000c 1C16      		cp __zero_reg__,r28	 ;  9	*reversed_tsthi	[length = 2]
  40 000e 1D06      		cpc __zero_reg__,r29
  41 0010 04F4      		brge .L1	 ;  10	branch	[length = 1]
  42               	.LVL3:
  43               	.L4:
  44               	.LBB21:
  45               	.LBB22:
  46               		.file 2 "../../libtinyasuro/inc/asuro/time.h"
   1:../../libtinyasuro/inc/asuro/time.h **** /**
   2:../../libtinyasuro/inc/asuro/time.h ****  * @file
   3:../../libtinyasuro/inc/asuro/time.h ****  *
   4:../../libtinyasuro/inc/asuro/time.h ****  * \if de
   5:../../libtinyasuro/inc/asuro/time.h ****  * Definiert die Schnittstelle für die Verwendung des Timer2 als gemeinsame
   6:../../libtinyasuro/inc/asuro/time.h ****  * Zeitbasis und Taktquelle.
   7:../../libtinyasuro/inc/asuro/time.h ****  *
   8:../../libtinyasuro/inc/asuro/time.h ****  * Es werden Funktionen definiert, die es ermöglichen, den Prozessor für einen
   9:../../libtinyasuro/inc/asuro/time.h ****  * definierten Zeitraum oder bis zum nächsten Interrupt in den Idle-Mode zu
  10:../../libtinyasuro/inc/asuro/time.h ****  * versetzen (unter Verwendung der Funktionalität aus avr/sleep.h).
  11:../../libtinyasuro/inc/asuro/time.h ****  *
  12:../../libtinyasuro/inc/asuro/time.h ****  * Außerdem wird die Möglichkeit geboten, die Taktausgabe für die
  13:../../libtinyasuro/inc/asuro/time.h ****  * IR-Schnittstelle ein- und auszuschalten.
  14:../../libtinyasuro/inc/asuro/time.h ****  *
  15:../../libtinyasuro/inc/asuro/time.h ****  * Zusätzlich besteht die Möglichkeit, eine eigene Funktion in der mit 36kHz
  16:../../libtinyasuro/inc/asuro/time.h ****  * aufgerufenen Timer2-ISR auszuführen, sofern diese Option in hooks.h aktiviert
  17:../../libtinyasuro/inc/asuro/time.h ****  * ist.
  18:../../libtinyasuro/inc/asuro/time.h ****  *
  19:../../libtinyasuro/inc/asuro/time.h ****  * @par Wichtiger Hinweis:
  20:../../libtinyasuro/inc/asuro/time.h ****  *      Für eine korrekte Funktion des Moduls müssen Interrupts global
  21:../../libtinyasuro/inc/asuro/time.h ****  *      freigeschaltet sein, Ausnahmen sind für kurze Zeitspannen zulässig,
  22:../../libtinyasuro/inc/asuro/time.h ****  *      können aber die Genauigkeit negativ beeinflussen.
  23:../../libtinyasuro/inc/asuro/time.h ****  *
  24:../../libtinyasuro/inc/asuro/time.h ****  * @par Initialisierung:
  25:../../libtinyasuro/inc/asuro/time.h ****  *      Vor der Verwendung des Moduls muss Timer2Init() aufgerufen werden, zudem
  26:../../libtinyasuro/inc/asuro/time.h ****  *      wird eine globale Interruptfreigabe benötigt.
  27:../../libtinyasuro/inc/asuro/time.h ****  *
  28:../../libtinyasuro/inc/asuro/time.h ****  * @par Genutzte Hardwareressourcen:
  29:../../libtinyasuro/inc/asuro/time.h ****  *      Module:
  30:../../libtinyasuro/inc/asuro/time.h ****  *      @li Timer2
  31:../../libtinyasuro/inc/asuro/time.h ****  *
  32:../../libtinyasuro/inc/asuro/time.h ****  *      Interruptvektoren:
  33:../../libtinyasuro/inc/asuro/time.h ****  *      @li TIMER2_OVF
  34:../../libtinyasuro/inc/asuro/time.h ****  *
  35:../../libtinyasuro/inc/asuro/time.h ****  *      I/O:
  36:../../libtinyasuro/inc/asuro/time.h ****  *      @li Port B: Pin 3 (36kHz-Träger der IR-Schnittstelle)
  37:../../libtinyasuro/inc/asuro/time.h ****  * \endif
  38:../../libtinyasuro/inc/asuro/time.h ****  *
  39:../../libtinyasuro/inc/asuro/time.h ****  * \if en
  40:../../libtinyasuro/inc/asuro/time.h ****  * Interface definitions to use timer2 as common clock source and time
  41:../../libtinyasuro/inc/asuro/time.h ****  * reference.
  42:../../libtinyasuro/inc/asuro/time.h ****  *
  43:../../libtinyasuro/inc/asuro/time.h ****  * This interface defines functions to put the microcontroller into idle mode
  44:../../libtinyasuro/inc/asuro/time.h ****  * for either a defined timespan or until the next interrupt occurs. The
  45:../../libtinyasuro/inc/asuro/time.h ****  * functionality in avr/sleep.h is used for this purpose.
  46:../../libtinyasuro/inc/asuro/time.h ****  *
  47:../../libtinyasuro/inc/asuro/time.h ****  * The carrier clock for the IR communications interface can be controlled
  48:../../libtinyasuro/inc/asuro/time.h ****  * using this interface.
  49:../../libtinyasuro/inc/asuro/time.h ****  *
  50:../../libtinyasuro/inc/asuro/time.h ****  * Timer2 is operating with a frequency of 36kHz, custom code can be executed
  51:../../libtinyasuro/inc/asuro/time.h ****  * by an ISR of timer2 if this feature is enabled in hooks.h.
  52:../../libtinyasuro/inc/asuro/time.h ****  *
  53:../../libtinyasuro/inc/asuro/time.h ****  * @par Important:
  54:../../libtinyasuro/inc/asuro/time.h ****  *      This module requires interrupts to be enabled globally. Short term
  55:../../libtinyasuro/inc/asuro/time.h ****  *      exceptions may be permittable but can have a negative effect on the
  56:../../libtinyasuro/inc/asuro/time.h ****  *      accuracy of the provided clock.
  57:../../libtinyasuro/inc/asuro/time.h ****  *
  58:../../libtinyasuro/inc/asuro/time.h ****  * @par Initialization:
  59:../../libtinyasuro/inc/asuro/time.h ****  *      Timer2Init() must be called before using this module. Interrupts must be
  60:../../libtinyasuro/inc/asuro/time.h ****  *      enabled globally.
  61:../../libtinyasuro/inc/asuro/time.h ****  *
  62:../../libtinyasuro/inc/asuro/time.h ****  * @par Hardware resources in use:
  63:../../libtinyasuro/inc/asuro/time.h ****  *      Components:
  64:../../libtinyasuro/inc/asuro/time.h ****  *      @li Timer2
  65:../../libtinyasuro/inc/asuro/time.h ****  *
  66:../../libtinyasuro/inc/asuro/time.h ****  *      Interrupt vectors:
  67:../../libtinyasuro/inc/asuro/time.h ****  *      @li TIMER2_OVF
  68:../../libtinyasuro/inc/asuro/time.h ****  *
  69:../../libtinyasuro/inc/asuro/time.h ****  *      I/O:
  70:../../libtinyasuro/inc/asuro/time.h ****  *      @li Port B: Pin 3 (36kHz carrier signal for IR communications)
  71:../../libtinyasuro/inc/asuro/time.h ****  * \endif
  72:../../libtinyasuro/inc/asuro/time.h ****  *
  73:../../libtinyasuro/inc/asuro/time.h ****  * @see hooks.h
  74:../../libtinyasuro/inc/asuro/time.h ****  *
  75:../../libtinyasuro/inc/asuro/time.h ****  * @author Markus Jung
  76:../../libtinyasuro/inc/asuro/time.h ****  *
  77:../../libtinyasuro/inc/asuro/time.h ****  * @version 23.05.2010 \n
  78:../../libtinyasuro/inc/asuro/time.h ****  *  Schnittstellendefinition entsprechend asuro.h
  79:../../libtinyasuro/inc/asuro/time.h ****  * @version 28.05.2010 \n
  80:../../libtinyasuro/inc/asuro/time.h ****  *  Zählervariable zugänglich gemacht
  81:../../libtinyasuro/inc/asuro/time.h ****  * @version 02.06.2010 \n
  82:../../libtinyasuro/inc/asuro/time.h ****  *  sleepUntilInterrupt implementiert
  83:../../libtinyasuro/inc/asuro/time.h ****  * @version 15.06.2010 \n
  84:../../libtinyasuro/inc/asuro/time.h ****  *  Doku
  85:../../libtinyasuro/inc/asuro/time.h ****  * @version 26.06.2010 \n
  86:../../libtinyasuro/inc/asuro/time.h ****  *  Alias-Makros für sleep, msleep und sleepUntilInterrupt hinzugefügt
  87:../../libtinyasuro/inc/asuro/time.h ****  *  (zwecks konsistentem Namensschema)
  88:../../libtinyasuro/inc/asuro/time.h ****  * @version 16.08.2010 \n
  89:../../libtinyasuro/inc/asuro/time.h ****  *  + Hook für Timer2ISR
  90:../../libtinyasuro/inc/asuro/time.h ****  * @version 13.09.2013 \n
  91:../../libtinyasuro/inc/asuro/time.h ****  *  English documentation
  92:../../libtinyasuro/inc/asuro/time.h ****  * @version 29.10.2013 \n
  93:../../libtinyasuro/inc/asuro/time.h ****  *  Document interrupt safety issues of TIMER2_CLOCK_OUT_ENABLE() and
  94:../../libtinyasuro/inc/asuro/time.h ****  *  TIMER2_CLOCK_OUT_DISABLE()
  95:../../libtinyasuro/inc/asuro/time.h ****  */
  96:../../libtinyasuro/inc/asuro/time.h **** /*
  97:../../libtinyasuro/inc/asuro/time.h ****  * The contents of this file are subject to the terms of the Common Development
  98:../../libtinyasuro/inc/asuro/time.h ****  * and Distribution License Version 1.0 (the License).
  99:../../libtinyasuro/inc/asuro/time.h ****  * You may not use this file except in compliance with the License.
 100:../../libtinyasuro/inc/asuro/time.h ****  *
 101:../../libtinyasuro/inc/asuro/time.h ****  * If not included, you can obtain a copy of the License at
 102:../../libtinyasuro/inc/asuro/time.h ****  * http://www.sun.com/cddl/cddl.html
 103:../../libtinyasuro/inc/asuro/time.h ****  *
 104:../../libtinyasuro/inc/asuro/time.h ****  * When distributing Covered Code, include this CDDL Header Notice in each file
 105:../../libtinyasuro/inc/asuro/time.h ****  * and include the provided License file.
 106:../../libtinyasuro/inc/asuro/time.h ****  */
 107:../../libtinyasuro/inc/asuro/time.h **** 
 108:../../libtinyasuro/inc/asuro/time.h **** #ifndef TIME_H_
 109:../../libtinyasuro/inc/asuro/time.h **** #define TIME_H_
 110:../../libtinyasuro/inc/asuro/time.h **** 
 111:../../libtinyasuro/inc/asuro/time.h **** #include <stdbool.h>
 112:../../libtinyasuro/inc/asuro/time.h **** #include <stdint.h>
 113:../../libtinyasuro/inc/asuro/time.h **** #include "hooks.h"
 114:../../libtinyasuro/inc/asuro/time.h **** #include "../util/misc.h"
 115:../../libtinyasuro/inc/asuro/time.h **** 
 116:../../libtinyasuro/inc/asuro/time.h **** #ifdef __DOXYGEN__
 117:../../libtinyasuro/inc/asuro/time.h **** /** \if de
 118:../../libtinyasuro/inc/asuro/time.h ****  * Alias-Makro für sleep().
 119:../../libtinyasuro/inc/asuro/time.h ****  * \endif
 120:../../libtinyasuro/inc/asuro/time.h ****  *
 121:../../libtinyasuro/inc/asuro/time.h ****  * \if en
 122:../../libtinyasuro/inc/asuro/time.h ****  * Alias macro for sleep().
 123:../../libtinyasuro/inc/asuro/time.h ****  * \endif
 124:../../libtinyasuro/inc/asuro/time.h ****  */
 125:../../libtinyasuro/inc/asuro/time.h **** #define Sleep
 126:../../libtinyasuro/inc/asuro/time.h **** /** \if de
 127:../../libtinyasuro/inc/asuro/time.h ****  * Alias-Makro für msleep().
 128:../../libtinyasuro/inc/asuro/time.h ****  * \endif
 129:../../libtinyasuro/inc/asuro/time.h ****  *
 130:../../libtinyasuro/inc/asuro/time.h ****  * \if en
 131:../../libtinyasuro/inc/asuro/time.h ****  * Alias macro for msleep().
 132:../../libtinyasuro/inc/asuro/time.h ****  * \endif
 133:../../libtinyasuro/inc/asuro/time.h ****  */
 134:../../libtinyasuro/inc/asuro/time.h **** #define Msleep
 135:../../libtinyasuro/inc/asuro/time.h **** /** \if de
 136:../../libtinyasuro/inc/asuro/time.h ****  * Alias-Makro für sleepUntilInterrupt().
 137:../../libtinyasuro/inc/asuro/time.h ****  * \endif
 138:../../libtinyasuro/inc/asuro/time.h ****  *
 139:../../libtinyasuro/inc/asuro/time.h ****  * \if en
 140:../../libtinyasuro/inc/asuro/time.h ****  * Alias macro for sleepUntilInterrupt().
 141:../../libtinyasuro/inc/asuro/time.h ****  * \endif
 142:../../libtinyasuro/inc/asuro/time.h ****  */
 143:../../libtinyasuro/inc/asuro/time.h **** #define SleepUntilInterrupt
 144:../../libtinyasuro/inc/asuro/time.h **** #else
 145:../../libtinyasuro/inc/asuro/time.h **** #define Sleep               sleep
 146:../../libtinyasuro/inc/asuro/time.h **** #define Msleep              msleep
 147:../../libtinyasuro/inc/asuro/time.h **** #define SleepUntilInterrupt sleepUntilInterrupt
 148:../../libtinyasuro/inc/asuro/time.h **** #endif
 149:../../libtinyasuro/inc/asuro/time.h **** 
 150:../../libtinyasuro/inc/asuro/time.h **** /**
 151:../../libtinyasuro/inc/asuro/time.h ****  * \if de
 152:../../libtinyasuro/inc/asuro/time.h ****  * Eine Zählvariable die im 36kHz-Takt (um eins) inkrementiert wird.
 153:../../libtinyasuro/inc/asuro/time.h ****  * \endif
 154:../../libtinyasuro/inc/asuro/time.h ****  *
 155:../../libtinyasuro/inc/asuro/time.h ****  * \if en
 156:../../libtinyasuro/inc/asuro/time.h ****  * A counting variable incremented from the 36kHz clock.
 157:../../libtinyasuro/inc/asuro/time.h ****  * \endif
 158:../../libtinyasuro/inc/asuro/time.h ****  */
 159:../../libtinyasuro/inc/asuro/time.h **** extern volatile uint8_t tick36kHz; // counts from 0 to 255
 160:../../libtinyasuro/inc/asuro/time.h **** 
 161:../../libtinyasuro/inc/asuro/time.h **** #ifdef __DOXYGEN__
 162:../../libtinyasuro/inc/asuro/time.h **** /**
 163:../../libtinyasuro/inc/asuro/time.h ****  * \if de
 164:../../libtinyasuro/inc/asuro/time.h ****  * Bietet die Möglichkeit, eine eigene Funktion bei jedem Aufruf der Timer-ISR
 165:../../libtinyasuro/inc/asuro/time.h ****  * auszuführen. Die interne Funktionalität bleibt dabei erhalten.
 166:../../libtinyasuro/inc/asuro/time.h ****  *
 167:../../libtinyasuro/inc/asuro/time.h ****  * Da die Timer-ISR mit einer Frequenz von 36kHz aufgerufen wird, sollte diese
 168:../../libtinyasuro/inc/asuro/time.h ****  * Funktion möglichst kurz sein.
 169:../../libtinyasuro/inc/asuro/time.h ****  *
 170:../../libtinyasuro/inc/asuro/time.h ****  * Der Aufruf erfolgt aus dem Kontext eines Interrupts!
 171:../../libtinyasuro/inc/asuro/time.h ****  *
 172:../../libtinyasuro/inc/asuro/time.h ****  * Ist (Timer2ISRHook == NULL), findet kein Aufruf statt.
 173:../../libtinyasuro/inc/asuro/time.h ****  *
 174:../../libtinyasuro/inc/asuro/time.h ****  * Diese Funktionalität steht nicht zur Verfügung, wenn TIMER2_ISR_HOOK_ENABLE
 175:../../libtinyasuro/inc/asuro/time.h ****  * deaktiviert ist.
 176:../../libtinyasuro/inc/asuro/time.h ****  * \endif
 177:../../libtinyasuro/inc/asuro/time.h ****  *
 178:../../libtinyasuro/inc/asuro/time.h ****  * \if en
 179:../../libtinyasuro/inc/asuro/time.h ****  * Offers the ability to execute a custom function in addition to the internal
 180:../../libtinyasuro/inc/asuro/time.h ****  * code of the timer ISR.
 181:../../libtinyasuro/inc/asuro/time.h ****  *
 182:../../libtinyasuro/inc/asuro/time.h ****  * Since the ISR will be executed with a frequency of 36kHz, the called function
 183:../../libtinyasuro/inc/asuro/time.h ****  * should be as short as possible.
 184:../../libtinyasuro/inc/asuro/time.h ****  *
 185:../../libtinyasuro/inc/asuro/time.h ****  * The function will be called from an interrupt context!
 186:../../libtinyasuro/inc/asuro/time.h ****  *
 187:../../libtinyasuro/inc/asuro/time.h ****  * No function call will be executed if (Timer2ISRHook == NULL).
 188:../../libtinyasuro/inc/asuro/time.h ****  *
 189:../../libtinyasuro/inc/asuro/time.h ****  * The timer hook feature is not available if TIMER2_ISR_HOOK_ENABLE has been
 190:../../libtinyasuro/inc/asuro/time.h ****  * disabled.
 191:../../libtinyasuro/inc/asuro/time.h ****  * \endif
 192:../../libtinyasuro/inc/asuro/time.h ****  */
 193:../../libtinyasuro/inc/asuro/time.h **** extern ISRHookFunc_t *Timer2ISRHook;
 194:../../libtinyasuro/inc/asuro/time.h **** #else  // !__DOXYGEN__
 195:../../libtinyasuro/inc/asuro/time.h **** #if TIMER2_ISR_HOOK_ENABLE
 196:../../libtinyasuro/inc/asuro/time.h **** extern ISRHookFunc_t *Timer2ISRHook;
 197:../../libtinyasuro/inc/asuro/time.h **** #endif
 198:../../libtinyasuro/inc/asuro/time.h **** #endif
 199:../../libtinyasuro/inc/asuro/time.h **** 
 200:../../libtinyasuro/inc/asuro/time.h **** /**
 201:../../libtinyasuro/inc/asuro/time.h ****  * \if de
 202:../../libtinyasuro/inc/asuro/time.h ****  * Initialisiert das Modul und den als Zeitbasis und Taktgenerator für die
 203:../../libtinyasuro/inc/asuro/time.h ****  * Infrarotschnittstelle verwendeten Timer2.
 204:../../libtinyasuro/inc/asuro/time.h ****  *
 205:../../libtinyasuro/inc/asuro/time.h ****  * Nach der Initialisierung ist die Taktausgabe für die Infrarotschnittstelle
 206:../../libtinyasuro/inc/asuro/time.h ****  * deaktiviert.
 207:../../libtinyasuro/inc/asuro/time.h ****  * \endif
 208:../../libtinyasuro/inc/asuro/time.h ****  *
 209:../../libtinyasuro/inc/asuro/time.h ****  * \if en
 210:../../libtinyasuro/inc/asuro/time.h ****  * Initializes the module and timer2 which is used as time reference and clock
 211:../../libtinyasuro/inc/asuro/time.h ****  * source for the IR communications interface.
 212:../../libtinyasuro/inc/asuro/time.h ****  *
 213:../../libtinyasuro/inc/asuro/time.h ****  * The clock output for the IR interface will be in a disabled state after the
 214:../../libtinyasuro/inc/asuro/time.h ****  * initialization has been completed.
 215:../../libtinyasuro/inc/asuro/time.h ****  * \endif
 216:../../libtinyasuro/inc/asuro/time.h ****  */
 217:../../libtinyasuro/inc/asuro/time.h **** extern void Timer2Init(void);
 218:../../libtinyasuro/inc/asuro/time.h **** 
 219:../../libtinyasuro/inc/asuro/time.h **** /**
 220:../../libtinyasuro/inc/asuro/time.h ****  * \if de
 221:../../libtinyasuro/inc/asuro/time.h ****  * Aktiviert die Ausgabe des 36kHz-Signals für die Infrarotschnittstelle.
 222:../../libtinyasuro/inc/asuro/time.h ****  *
 223:../../libtinyasuro/inc/asuro/time.h ****  * @par Wichtiger Hinweis:
 224:../../libtinyasuro/inc/asuro/time.h ****  * Dieses Makro ist nur eingeschänkt interruptfest. Es darf nicht "parallel" zu
 225:../../libtinyasuro/inc/asuro/time.h ****  * TIMER2_CLOCK_OUT_DISABLE() ausgeführt werden.
 226:../../libtinyasuro/inc/asuro/time.h ****  * \endif
 227:../../libtinyasuro/inc/asuro/time.h ****  *
 228:../../libtinyasuro/inc/asuro/time.h ****  * \if en
 229:../../libtinyasuro/inc/asuro/time.h ****  * Enables the 36kHz carrier signal for the IR communications interface.
 230:../../libtinyasuro/inc/asuro/time.h ****  *
 231:../../libtinyasuro/inc/asuro/time.h ****  * @par Important:
 232:../../libtinyasuro/inc/asuro/time.h ****  * This macro is interrupt-safe except for one restriction. It must not be
 233:../../libtinyasuro/inc/asuro/time.h ****  * executed in parallel to TIMER2_CLOCK_OUT_DISABLE().
 234:../../libtinyasuro/inc/asuro/time.h ****  * \endif
 235:../../libtinyasuro/inc/asuro/time.h ****  */
 236:../../libtinyasuro/inc/asuro/time.h **** #ifdef __DOXYGEN__
 237:../../libtinyasuro/inc/asuro/time.h **** #define TIMER2_CLOCK_OUT_ENABLE()
 238:../../libtinyasuro/inc/asuro/time.h **** #else
 239:../../libtinyasuro/inc/asuro/time.h **** #define TIMER2_CLOCK_OUT_ENABLE() \
 240:../../libtinyasuro/inc/asuro/time.h ****     do { /* Fast PWM, BOTTOM: Clear, CompMatch: Set */ \
 241:../../libtinyasuro/inc/asuro/time.h ****         TCCR2 |= (1 << WGM20) | (1 << WGM21) | (1 << COM20) | (1 << COM21); \
 242:../../libtinyasuro/inc/asuro/time.h ****     } while (false)
 243:../../libtinyasuro/inc/asuro/time.h **** #endif
 244:../../libtinyasuro/inc/asuro/time.h **** 
 245:../../libtinyasuro/inc/asuro/time.h **** /**
 246:../../libtinyasuro/inc/asuro/time.h ****  * \if de
 247:../../libtinyasuro/inc/asuro/time.h ****  * Deaktiviert die Ausgabe des 36kHz-Signals für die Infrarotschnittstelle.
 248:../../libtinyasuro/inc/asuro/time.h ****  *
 249:../../libtinyasuro/inc/asuro/time.h ****  * @par Wichtiger Hinweis:
 250:../../libtinyasuro/inc/asuro/time.h ****  * Dieses Makro ist nur eingeschränkt interruptfest. Es darf nicht "parallel"
 251:../../libtinyasuro/inc/asuro/time.h ****  * zu TIMER2_CLOCK_OUT_ENABLE() ausgeführt werden.
 252:../../libtinyasuro/inc/asuro/time.h ****  * \endif
 253:../../libtinyasuro/inc/asuro/time.h ****  *
 254:../../libtinyasuro/inc/asuro/time.h ****  * \if en
 255:../../libtinyasuro/inc/asuro/time.h ****  * Disables the 36kHz carrier signal for the IR communications interface.
 256:../../libtinyasuro/inc/asuro/time.h ****  *
 257:../../libtinyasuro/inc/asuro/time.h ****  * @par Important:
 258:../../libtinyasuro/inc/asuro/time.h ****  * This macro is interrupt-safe except for one restriction. It must not be
 259:../../libtinyasuro/inc/asuro/time.h ****  * executed in parallel to TIMER2_CLOCK_OUT_ENABLE().
 260:../../libtinyasuro/inc/asuro/time.h ****  * \endif
 261:../../libtinyasuro/inc/asuro/time.h ****  */
 262:../../libtinyasuro/inc/asuro/time.h **** #ifdef __DOXYGEN__
 263:../../libtinyasuro/inc/asuro/time.h **** #define TIMER2_CLOCK_OUT_DISABLE()
 264:../../libtinyasuro/inc/asuro/time.h **** #else
 265:../../libtinyasuro/inc/asuro/time.h **** #define TIMER2_CLOCK_OUT_DISABLE() \
 266:../../libtinyasuro/inc/asuro/time.h ****     do { /* PWM off */ \
 267:../../libtinyasuro/inc/asuro/time.h ****         TCCR2 &= ~((1 << WGM20) | (1 << WGM21) | (1 << COM20) | (1 << COM21)); \
 268:../../libtinyasuro/inc/asuro/time.h ****     } while (false)
 269:../../libtinyasuro/inc/asuro/time.h **** #endif
 270:../../libtinyasuro/inc/asuro/time.h **** 
 271:../../libtinyasuro/inc/asuro/time.h **** /**
 272:../../libtinyasuro/inc/asuro/time.h ****  * \if de
 273:../../libtinyasuro/inc/asuro/time.h ****  * Hält den Programmfluss für die vorgegebene Anzahl 36kHz-Takte an und schickt
 274:../../libtinyasuro/inc/asuro/time.h ****  * den Prozessor währendessen in den Idle-Mode.
 275:../../libtinyasuro/inc/asuro/time.h ****  *
 276:../../libtinyasuro/inc/asuro/time.h ****  * Alle Interrupts bleiben aktiv und werden ausgeführt, ledliglich der
 277:../../libtinyasuro/inc/asuro/time.h ****  * aufrufende Programmpfad wird unterbrochen.
 278:../../libtinyasuro/inc/asuro/time.h ****  *
 279:../../libtinyasuro/inc/asuro/time.h ****  * Wenn diese Funktion aufgerufen wird, geht sie davon aus, dass Interrupts
 280:../../libtinyasuro/inc/asuro/time.h ****  * global freigeschaltet sind - wenn nicht findet die globale Interruptfreigabe
 281:../../libtinyasuro/inc/asuro/time.h ****  * vor Eintritt in den Idle-Mode statt.
 282:../../libtinyasuro/inc/asuro/time.h ****  *
 283:../../libtinyasuro/inc/asuro/time.h ****  * @param timer36kHz_ticks die Anzahl der 36kHz-Takte die der Prozessor
 284:../../libtinyasuro/inc/asuro/time.h ****  *                         "schlafen" soll
 285:../../libtinyasuro/inc/asuro/time.h ****  * \endif
 286:../../libtinyasuro/inc/asuro/time.h ****  *
 287:../../libtinyasuro/inc/asuro/time.h ****  * \if en
 288:../../libtinyasuro/inc/asuro/time.h ****  * Delays the execution for the specified amount of time, measured in 36kHz
 289:../../libtinyasuro/inc/asuro/time.h ****  * ticks. The microcontroller will halted (idle mode) during this time.
 290:../../libtinyasuro/inc/asuro/time.h ****  *
 291:../../libtinyasuro/inc/asuro/time.h ****  * All interrupt requests remain active and will be executed, the calling
 292:../../libtinyasuro/inc/asuro/time.h ****  * function itself remains halted.
 293:../../libtinyasuro/inc/asuro/time.h ****  *
 294:../../libtinyasuro/inc/asuro/time.h ****  * This function expects interrupts to be globally enabled if it gets called.
 295:../../libtinyasuro/inc/asuro/time.h ****  * If not, the global interrupt enable bit will be set before entering the sleep
 296:../../libtinyasuro/inc/asuro/time.h ****  * mode and remain in this state after the function returns.
 297:../../libtinyasuro/inc/asuro/time.h ****  *
 298:../../libtinyasuro/inc/asuro/time.h ****  * @param timer36kHz_ticks the number of 36kHz ticks the microcontroller will
 299:../../libtinyasuro/inc/asuro/time.h ****  *                         be halted.
 300:../../libtinyasuro/inc/asuro/time.h ****  * \endif
 301:../../libtinyasuro/inc/asuro/time.h ****  */
 302:../../libtinyasuro/inc/asuro/time.h **** extern void sleep(uint8_t timer36kHz_ticks);
 303:../../libtinyasuro/inc/asuro/time.h **** /**
 304:../../libtinyasuro/inc/asuro/time.h ****  * \if de
 305:../../libtinyasuro/inc/asuro/time.h ****  * Schickt den Prozessor in den Idle-Mode und kehrt zurück, nachdem ein
 306:../../libtinyasuro/inc/asuro/time.h ****  * Interrupt ausgelöst wurde.
 307:../../libtinyasuro/inc/asuro/time.h ****  *
 308:../../libtinyasuro/inc/asuro/time.h ****  * Wenn diese Funktion aufgerufen wird, geht sie davon aus, dass Interrupts
 309:../../libtinyasuro/inc/asuro/time.h ****  * global freigeschaltet sind - wenn nicht findet die globale Interruptfreigabe
 310:../../libtinyasuro/inc/asuro/time.h ****  * vor Eintritt in den Idle-Mode statt.
 311:../../libtinyasuro/inc/asuro/time.h ****  * \endif
 312:../../libtinyasuro/inc/asuro/time.h ****  *
 313:../../libtinyasuro/inc/asuro/time.h ****  * \if en
 314:../../libtinyasuro/inc/asuro/time.h ****  * Puts the microcontroller into idle mode until the next interrupt occurs.
 315:../../libtinyasuro/inc/asuro/time.h ****  *
 316:../../libtinyasuro/inc/asuro/time.h ****  * This function expects interrupts to be globally enabled if it gets called.
 317:../../libtinyasuro/inc/asuro/time.h ****  * If not, the global interrupt enable bit will be set before entering the sleep
 318:../../libtinyasuro/inc/asuro/time.h ****  * mode and remain in this state after the function returns.
 319:../../libtinyasuro/inc/asuro/time.h ****  * \endif
 320:../../libtinyasuro/inc/asuro/time.h ****  */
 321:../../libtinyasuro/inc/asuro/time.h **** extern void sleepUntilInterrupt(void);
 322:../../libtinyasuro/inc/asuro/time.h **** 
 323:../../libtinyasuro/inc/asuro/time.h **** /**
 324:../../libtinyasuro/inc/asuro/time.h ****  * \if de
 325:../../libtinyasuro/inc/asuro/time.h ****  * Verhält sich wie sleep(), verwendet als Zeitbasis aber Millisekunden
 326:../../libtinyasuro/inc/asuro/time.h ****  *
 327:../../libtinyasuro/inc/asuro/time.h ****  * @param ms die Anzahl der Millisekunden die der Prozessor "schlafend"
 328:../../libtinyasuro/inc/asuro/time.h ****  *           verbringen soll
 329:../../libtinyasuro/inc/asuro/time.h ****  * \endif
 330:../../libtinyasuro/inc/asuro/time.h ****  *
 331:../../libtinyasuro/inc/asuro/time.h ****  * \if en
 332:../../libtinyasuro/inc/asuro/time.h ****  * Behaves like sleep() but uses milliseconds as timebase.
 333:../../libtinyasuro/inc/asuro/time.h ****  *
 334:../../libtinyasuro/inc/asuro/time.h ****  * @param ms the time the microcontroller will be halted, measured in
 335:../../libtinyasuro/inc/asuro/time.h ****  *           milliseconds
 336:../../libtinyasuro/inc/asuro/time.h ****  * \endif
 337:../../libtinyasuro/inc/asuro/time.h ****  */
 338:../../libtinyasuro/inc/asuro/time.h **** #ifdef __DOXYGEN__
 339:../../libtinyasuro/inc/asuro/time.h **** void msleep(uint16_t ms);
 340:../../libtinyasuro/inc/asuro/time.h **** #else
 341:../../libtinyasuro/inc/asuro/time.h **** static ALWAYS_INLINE void msleep(uint16_t ms);
 342:../../libtinyasuro/inc/asuro/time.h **** #endif
 343:../../libtinyasuro/inc/asuro/time.h **** 
 344:../../libtinyasuro/inc/asuro/time.h **** void msleep(uint16_t ms) {
 345:../../libtinyasuro/inc/asuro/time.h ****     for (; ms > 0; ms--) {
 346:../../libtinyasuro/inc/asuro/time.h ****         sleep(36);
  47               		.loc 2 346 0
  48 0012 84E2      		ldi r24,lo8(36)	 ;  21	movqi_insn/2	[length = 1]
  49 0014 00D0      		rcall sleep	 ;  22	call_insn/2	[length = 1]
  50               	.LVL4:
 345:../../libtinyasuro/inc/asuro/time.h ****         sleep(36);
  51               		.loc 2 345 0
  52 0016 2197      		sbiw r28,1	 ;  23	addhi3_clobber/1	[length = 1]
  53               	.LVL5:
  54 0018 2097      		sbiw r28,0	 ;  27	*cmphi/1	[length = 1]
  55 001a 01F4      		brne .L4	 ;  28	branch	[length = 1]
  56               	.LVL6:
  57               	.L1:
  58               	/* epilogue start */
  59               	.LBE22:
  60               	.LBE21:
   7:helpers.h     **** 		msleep(pause);
   8:helpers.h     **** }
  61               		.loc 1 8 0
  62 001c DF91      		pop r29	 ;  49	popqi	[length = 1]
  63 001e CF91      		pop r28	 ;  50	popqi	[length = 1]
  64 0020 0895      		ret	 ;  51	return_from_epilogue	[length = 1]
  65               		.cfi_endproc
  66               	.LFE3:
  68               		.section	.text.flashLED,"ax",@progbits
  69               	.global	flashLED
  71               	flashLED:
  72               	.LFB4:
   9:helpers.h     **** 
  10:helpers.h     **** void flashLED (int intervall)
  11:helpers.h     **** {
  73               		.loc 1 11 0
  74               		.cfi_startproc
  75               	.LVL7:
  76               	/* prologue: function */
  77               	/* frame size = 0 */
  78               	/* stack size = 0 */
  79               	.L__stack_usage = 0
  80 0000 182F      		mov r17,r24	 ;  40	movqi_insn/1	[length = 1]
  81 0002 092F      		mov r16,r25	 ;  41	movqi_insn/1	[length = 1]
  82               	.LVL8:
  83               	.L12:
  84               	.LBB23:
  12:helpers.h     **** 	while (1)
  13:helpers.h     **** 	{
  14:helpers.h     **** 		int sstatus = 0;
  15:helpers.h     **** 		switch (sstatus)
  16:helpers.h     **** 		{
  17:helpers.h     **** 			case 0:
  18:helpers.h     **** 			StatusLED(RED);
  85               		.loc 1 18 0
  86 0004 82E0      		ldi r24,lo8(2)	 ;  8	movqi_insn/2	[length = 1]
  87 0006 00D0      		rcall StatusLED	 ;  9	call_insn/2	[length = 1]
  88               	.LVL9:
  19:helpers.h     **** 			sstatus = 1;
  20:helpers.h     **** 			break;
  21:helpers.h     **** 			
  22:helpers.h     **** 			case 1:
  23:helpers.h     **** 			StatusLED(GREEN);
  24:helpers.h     **** 			sstatus = 2;
  25:helpers.h     **** 			break;
  26:helpers.h     **** 			
  27:helpers.h     **** 			case 2:
  28:helpers.h     **** 			StatusLED(YELLOW);
  29:helpers.h     **** 			sstatus = 0;
  30:helpers.h     **** 			break;
  31:helpers.h     **** 		}
  32:helpers.h     **** 		msleep(intervall);
  89               		.loc 1 32 0
  90 0008 C12F      		mov r28,r17	 ;  47	movqi_insn/1	[length = 1]
  91 000a D02F      		mov r29,r16	 ;  48	movqi_insn/1	[length = 1]
  92               	.LVL10:
  93               	.L10:
  94               	.LBB24:
  95               	.LBB25:
 345:../../libtinyasuro/inc/asuro/time.h ****         sleep(36);
  96               		.loc 2 345 0
  97 000c 2097      		sbiw r28,0	 ;  24	*cmphi/1	[length = 1]
  98 000e 01F0      		breq .L12	 ;  25	branch	[length = 1]
  99               		.loc 2 346 0
 100 0010 84E2      		ldi r24,lo8(36)	 ;  16	movqi_insn/2	[length = 1]
 101 0012 00D0      		rcall sleep	 ;  17	call_insn/2	[length = 1]
 102               	.LVL11:
 345:../../libtinyasuro/inc/asuro/time.h ****         sleep(36);
 103               		.loc 2 345 0
 104 0014 2197      		sbiw r28,1	 ;  18	addhi3_clobber/1	[length = 1]
 105               	.LVL12:
 106 0016 00C0      		rjmp .L10	 ;  50	jump	[length = 1]
 107               	.LBE25:
 108               	.LBE24:
 109               	.LBE23:
 110               		.cfi_endproc
 111               	.LFE4:
 113               		.section	.text.stopLED,"ax",@progbits
 114               	.global	stopLED
 116               	stopLED:
 117               	.LFB5:
  33:helpers.h     **** 	}
  34:helpers.h     **** }
  35:helpers.h     **** 
  36:helpers.h     **** void stopLED () 
  37:helpers.h     **** {
 118               		.loc 1 37 0
 119               		.cfi_startproc
 120               	/* prologue: function */
 121               	/* frame size = 0 */
 122               	/* stack size = 0 */
 123               	.L__stack_usage = 0
  38:helpers.h     **** 	StatusLED(OFF);
 124               		.loc 1 38 0
 125 0000 80E0      		ldi r24,0	 ;  5	movqi_insn/1	[length = 1]
 126 0002 00C0      		rjmp StatusLED	 ;  6	call_insn/4	[length = 1]
 127               	.LVL13:
 128               		.cfi_endproc
 129               	.LFE5:
 131               		.section	.text.startup.main,"ax",@progbits
 132               	.global	main
 134               	main:
 135               	.LFB10:
 136               		.file 3 "main.c"
   1:main.c        **** #define SWITCH(X) 1<<X
   2:main.c        **** 
   3:main.c        **** #include <asuro/asuro.h>
   4:main.c        **** #include "helpers.h"
   5:main.c        **** #include <stdlib.h>
   6:main.c        **** 
   7:main.c        **** void main(void) {
 137               		.loc 3 7 0
 138               		.cfi_startproc
 139 0000 CF93      		push r28	 ;  372	pushqi1/1	[length = 1]
 140               	.LCFI2:
 141               		.cfi_def_cfa_offset 3
 142               		.cfi_offset 28, -2
 143 0002 DF93      		push r29	 ;  373	pushqi1/1	[length = 1]
 144               	.LCFI3:
 145               		.cfi_def_cfa_offset 4
 146               		.cfi_offset 29, -3
 147               		 ; SP -= 4	 ;  377	*addhi3_sp	[length = 2]
 148 0004 00D0      		rcall .
 149 0006 00D0      		rcall .
 150               	.LCFI4:
 151               		.cfi_def_cfa_offset 8
 152 0008 CDB7      		in r28,__SP_L__	 ;  378	*movhi/8	[length = 2]
 153 000a DEB7      		in r29,__SP_H__
 154               	.LCFI5:
 155               		.cfi_def_cfa_register 28
 156               	/* prologue: function */
 157               	/* frame size = 4 */
 158               	/* stack size = 6 */
 159               	.L__stack_usage = 6
   8:main.c        ****     Init();
 160               		.loc 3 8 0
 161 000c 00D0      		rcall Init	 ;  17	call_insn/2	[length = 1]
 162               	.LVL14:
   9:main.c        ****     int status = 0;
  10:main.c        **** 	//int x = 160;
  11:main.c        **** 	//int y = 200;
  12:main.c        **** 	int i = 0;
 163               		.loc 3 12 0
 164 000e E12C      		mov r14,__zero_reg__	 ;  3	*movhi/2	[length = 2]
 165 0010 F12C      		mov r15,__zero_reg__
   9:main.c        ****     int status = 0;
 166               		.loc 3 9 0
 167 0012 00E0      		ldi r16,0	 ;  4	*movhi/2	[length = 2]
 168 0014 10E0      		ldi r17,0
 169               	.LBB26:
  13:main.c        **** 	while (1) {  			//Hauptschleife
  14:main.c        **** 		i++;
  15:main.c        **** 		char sensor = PollSwitch();
  16:main.c        **** 		sensor &= 0b00111111;
  17:main.c        **** 		MotorDir(FWD, FWD); //Werkeinstellung
  18:main.c        **** 		MotorSpeed(230, 200); 
  19:main.c        **** 		
  20:main.c        **** 		if (sensor > 0) 	//Abfrage der sechs Drucksensoren -> backwards
  21:main.c        **** 		{
  22:main.c        **** 			 MotorDir(BWD, BWD); 
  23:main.c        **** 			 MotorSpeed(60, 150);
  24:main.c        **** 			 msleep(800);
  25:main.c        **** 		}
  26:main.c        **** 		MotorDir(FWD, FWD); 
  27:main.c        **** 		uint16_t data[] = {0,0};
  28:main.c        **** 		LineData(data);
  29:main.c        **** 		
  30:main.c        **** 		LineData(data);
  31:main.c        **** 		while ((data[LEFT] > 500) || (data[RIGHT] > 500)) 	//Geschwindigkeit 0 bei Licht über 100E
  32:main.c        **** 		{	
  33:main.c        **** 			stopAsuro(500);
  34:main.c        **** 			LineData(data);
  35:main.c        **** 		} 
  36:main.c        **** 		
  37:main.c        **** 		if ( (i % 3000) == 0) {
 170               		.loc 3 37 0
 171 0016 28EB      		ldi r18,lo8(-72)	 ;  387	*reload_inhi	[length = 4]
 172 0018 A22E      		mov r10,r18
 173 001a 2BE0      		ldi r18,lo8(11)
 174 001c B22E      		mov r11,r18
 175               	.LBB27:
  38:main.c        **** 			int ran;
  39:main.c        **** 			ran = rand() % 2;
 176               		.loc 3 39 0
 177 001e 32E0      		ldi r19,lo8(2)	 ;  388	*reload_inhi	[length = 3]
 178 0020 832E      		mov r8,r19
 179 0022 912C      		mov r9,__zero_reg__
 180               	.LVL15:
 181               	.L36:
 182               	.LBE27:
  14:main.c        **** 		char sensor = PollSwitch();
 183               		.loc 3 14 0
 184 0024 2FEF      		ldi r18,-1	 ;  23	addhi3_clobber/3	[length = 3]
 185 0026 E21A      		sub r14,r18
 186 0028 F20A      		sbc r15,r18
 187               	.LVL16:
  15:main.c        **** 		sensor &= 0b00111111;
 188               		.loc 3 15 0
 189 002a 00D0      		rcall PollSwitch	 ;  25	call_value_insn/2	[length = 1]
 190               	.LVL17:
 191 002c D82E      		mov r13,r24	 ;  26	movqi_insn/1	[length = 1]
 192               	.LVL18:
  17:main.c        **** 		MotorSpeed(230, 200); 
 193               		.loc 3 17 0
 194 002e 60E2      		ldi r22,lo8(32)	 ;  29	movqi_insn/2	[length = 1]
 195 0030 80E2      		ldi r24,lo8(32)	 ;  30	movqi_insn/2	[length = 1]
 196 0032 00D0      		rcall MotorDir	 ;  31	call_insn/2	[length = 1]
 197               	.LVL19:
  18:main.c        **** 		
 198               		.loc 3 18 0
 199 0034 68EC      		ldi r22,lo8(-56)	 ;  32	movqi_insn/2	[length = 1]
 200 0036 86EE      		ldi r24,lo8(-26)	 ;  33	movqi_insn/2	[length = 1]
 201 0038 00D0      		rcall MotorSpeed	 ;  34	call_insn/2	[length = 1]
 202               	.LVL20:
  16:main.c        **** 		MotorDir(FWD, FWD); //Werkeinstellung
 203               		.loc 3 16 0
 204 003a 8D2D      		mov r24,r13	 ;  368	movqi_insn/1	[length = 1]
 205 003c 8F73      		andi r24,lo8(63)	 ;  35	andqi3/2	[length = 1]
 206               	.LVL21:
  20:main.c        **** 		{
 207               		.loc 3 20 0
 208 003e 01F4      		brne .L15	 ;  37	branch	[length = 1]
 209               	.LVL22:
 210               	.L17:
  26:main.c        **** 		uint16_t data[] = {0,0};
 211               		.loc 3 26 0
 212 0040 60E2      		ldi r22,lo8(32)	 ;  39	movqi_insn/2	[length = 1]
 213 0042 80E2      		ldi r24,lo8(32)	 ;  40	movqi_insn/2	[length = 1]
 214 0044 00D0      		rcall MotorDir	 ;  41	call_insn/2	[length = 1]
 215               	.LVL23:
  27:main.c        **** 		LineData(data);
 216               		.loc 3 27 0
 217 0046 1A82      		std Y+2,__zero_reg__	 ;  42	*movhi/4	[length = 2]
 218 0048 1982      		std Y+1,__zero_reg__
 219 004a 1C82      		std Y+4,__zero_reg__	 ;  43	*movhi/4	[length = 2]
 220 004c 1B82      		std Y+3,__zero_reg__
  28:main.c        **** 		
 221               		.loc 3 28 0
 222 004e CE01      		movw r24,r28	 ;  369	*movhi/1	[length = 1]
 223 0050 0196      		adiw r24,1	 ;  44	*addhi3/3	[length = 1]
 224 0052 00D0      		rcall LineData	 ;  45	call_insn/2	[length = 1]
 225               	.LVL24:
 226 0054 00C0      		rjmp .L48	 ;  389	jump	[length = 1]
 227               	.LVL25:
 228               	.L15:
  22:main.c        **** 			 MotorSpeed(60, 150);
 229               		.loc 3 22 0
 230 0056 60E1      		ldi r22,lo8(16)	 ;  52	movqi_insn/2	[length = 1]
 231 0058 80E1      		ldi r24,lo8(16)	 ;  53	movqi_insn/2	[length = 1]
 232               	.LVL26:
 233 005a 00D0      		rcall MotorDir	 ;  54	call_insn/2	[length = 1]
 234               	.LVL27:
  23:main.c        **** 			 msleep(800);
 235               		.loc 3 23 0
 236 005c 66E9      		ldi r22,lo8(-106)	 ;  55	movqi_insn/2	[length = 1]
 237 005e 8CE3      		ldi r24,lo8(60)	 ;  56	movqi_insn/2	[length = 1]
 238 0060 00D0      		rcall MotorSpeed	 ;  57	call_insn/2	[length = 1]
 239               	.LVL28:
 240 0062 90E2      		ldi r25,lo8(32)	 ;  386	*reload_inhi	[length = 4]
 241 0064 C92E      		mov r12,r25
 242 0066 93E0      		ldi r25,lo8(3)
 243 0068 D92E      		mov r13,r25
 244               	.LVL29:
 245               	.L18:
 246               	.LBB28:
 247               	.LBB29:
 248               		.loc 2 346 0
 249 006a 84E2      		ldi r24,lo8(36)	 ;  62	movqi_insn/2	[length = 1]
 250 006c 00D0      		rcall sleep	 ;  63	call_insn/2	[length = 1]
 251               	.LVL30:
 252 006e 81E0      		ldi r24,1	 ;  67	addhi3_clobber/3	[length = 3]
 253 0070 C81A      		sub r12,r24
 254 0072 D108      		sbc r13,__zero_reg__
 255               	.LVL31:
 345:../../libtinyasuro/inc/asuro/time.h ****         sleep(36);
 256               		.loc 2 345 0
 257 0074 C114      		cp r12,__zero_reg__	 ;  69	*cmphi/2	[length = 2]
 258 0076 D104      		cpc r13,__zero_reg__
 259 0078 01F4      		brne .L18	 ;  70	branch	[length = 1]
 260 007a 00C0      		rjmp .L17	 ;  392	jump	[length = 1]
 261               	.LVL32:
 262               	.L50:
 263               	.LBE29:
 264               	.LBE28:
  31:main.c        **** 		{	
 265               		.loc 3 31 0 discriminator 2
 266 007c 8B81      		ldd r24,Y+3	 ;  89	*movhi/3	[length = 2]
 267 007e 9C81      		ldd r25,Y+4
 268 0080 853F      		cpi r24,-11	 ;  90	*cmphi/7	[length = 2]
 269 0082 9140      		sbci r25,1
 270 0084 00F0      		brlo .L49	 ;  91	branch	[length = 1]
 271               	.L19:
  33:main.c        **** 			LineData(data);
 272               		.loc 3 33 0
 273 0086 84EF      		ldi r24,lo8(-12)	 ;  78	*movhi/5	[length = 2]
 274 0088 91E0      		ldi r25,lo8(1)
 275 008a 00D0      		rcall stopAsuro	 ;  79	call_insn/2	[length = 1]
 276               	.LVL33:
 277               	.L48:
  34:main.c        **** 		} 
 278               		.loc 3 34 0
 279 008c CE01      		movw r24,r28	 ;  371	*movhi/1	[length = 1]
 280 008e 0196      		adiw r24,1	 ;  80	*addhi3/3	[length = 1]
 281 0090 00D0      		rcall LineData	 ;  81	call_insn/2	[length = 1]
 282               	.LVL34:
  31:main.c        **** 		{	
 283               		.loc 3 31 0
 284 0092 8981      		ldd r24,Y+1	 ;  85	*movhi/3	[length = 2]
 285 0094 9A81      		ldd r25,Y+2
 286 0096 853F      		cpi r24,-11	 ;  86	*cmphi/7	[length = 2]
 287 0098 9140      		sbci r25,1
 288 009a 00F0      		brlo .L50	 ;  87	branch	[length = 1]
 289 009c 00C0      		rjmp .L19	 ;  397	jump	[length = 1]
 290               	.L49:
  37:main.c        **** 			int ran;
 291               		.loc 3 37 0
 292 009e C701      		movw r24,r14	 ;  361	*movhi/1	[length = 1]
 293 00a0 B501      		movw r22,r10	 ;  362	*movhi/1	[length = 1]
 294 00a2 00D0      		rcall __divmodhi4	 ;  363	*divmodhi4_call	[length = 1]
 295 00a4 892B      		or r24,r25	 ;  95	*cmphi/1	[length = 1]
 296 00a6 01F4      		brne .L21	 ;  96	branch	[length = 1]
 297               	.LBB30:
 298               		.loc 3 39 0
 299 00a8 00D0      		rcall rand	 ;  102	call_value_insn/2	[length = 1]
 300               	.LVL35:
 301 00aa B401      		movw r22,r8	 ;  357	*movhi/1	[length = 1]
 302 00ac 00D0      		rcall __divmodhi4	 ;  358	*divmodhi4_call	[length = 1]
 303               	.LVL36:
  40:main.c        **** 			if (ran) {
 304               		.loc 3 40 0
 305 00ae 892B      		or r24,r25	 ;  108	*cmphi/1	[length = 1]
 306 00b0 01F0      		breq .L21	 ;  109	branch	[length = 1]
  41:main.c        **** 				
  42:main.c        **** 				stopAsuro(3000);
 307               		.loc 3 42 0
 308 00b2 88EB      		ldi r24,lo8(-72)	 ;  307	*movhi/5	[length = 2]
 309 00b4 9BE0      		ldi r25,lo8(11)
 310 00b6 00D0      		rcall stopAsuro	 ;  112	call_insn/2	[length = 1]
 311               	.LVL37:
 312               	.L21:
 313               	.LBE30:
  43:main.c        **** 				
  44:main.c        **** 			}
  45:main.c        **** 		}
  46:main.c        **** 		switch (status) {
 314               		.loc 3 46 0
 315 00b8 0130      		cpi r16,1	 ;  115	*cmphi/6	[length = 2]
 316 00ba 1105      		cpc r17,__zero_reg__
 317 00bc 01F0      		breq .L24	 ;  536	branch_unspec	[length = 1]
 318 00be 04F4      		brge .L25	 ;  537	branch_unspec	[length = 1]
 319 00c0 0115      		cp r16,__zero_reg__	 ;  119	*cmphi/2	[length = 2]
 320 00c2 1105      		cpc r17,__zero_reg__
 321 00c4 01F4      		brne .L23	 ;  120	branch	[length = 1]
  47:main.c        **** 			
  48:main.c        **** 			case 0: 
  49:main.c        **** 			MotorSpeed(250, 175);
 322               		.loc 3 49 0
 323 00c6 6FEA      		ldi r22,lo8(-81)	 ;  132	movqi_insn/2	[length = 1]
 324 00c8 8AEF      		ldi r24,lo8(-6)	 ;  133	movqi_insn/2	[length = 1]
 325 00ca 00D0      		rcall MotorSpeed	 ;  134	call_insn/2	[length = 1]
 326               	.LVL38:
 327 00cc 00EA      		ldi r16,lo8(-96)	 ;  313	*movhi/5	[length = 2]
 328 00ce 1FE0      		ldi r17,lo8(15)
 329 00d0 00C0      		rjmp .L30	 ;  399	jump	[length = 1]
 330               	.LVL39:
 331               	.L25:
  46:main.c        **** 			
 332               		.loc 3 46 0
 333 00d2 0230      		cpi r16,2	 ;  124	*cmphi/6	[length = 2]
 334 00d4 1105      		cpc r17,__zero_reg__
 335 00d6 01F0      		breq .L27	 ;  125	branch	[length = 1]
 336 00d8 0330      		cpi r16,3	 ;  126	*cmphi/6	[length = 2]
 337 00da 1105      		cpc r17,__zero_reg__
 338 00dc 01F4      		brne .L23	 ;  127	branch	[length = 1]
  50:main.c        **** 			status = 1;
  51:main.c        **** 			msleep(4000);
  52:main.c        **** 			break;
  53:main.c        **** 			
  54:main.c        **** 			case 1: 
  55:main.c        **** 			MotorSpeed(80,140);
  56:main.c        **** 			status = 2;
  57:main.c        **** 			msleep(4000);
  58:main.c        **** 			break;
  59:main.c        **** 			
  60:main.c        **** 			case 2: 
  61:main.c        **** 			MotorSpeed(220, 205); 
  62:main.c        **** 			status = 3;
  63:main.c        **** 			msleep(4000);
  64:main.c        **** 			break;
  65:main.c        **** 			
  66:main.c        **** 			case 3: 
  67:main.c        **** 			MotorSpeed(200, 260); 
 339               		.loc 3 67 0
 340 00de 64E0      		ldi r22,lo8(4)	 ;  204	movqi_insn/2	[length = 1]
 341 00e0 88EC      		ldi r24,lo8(-56)	 ;  205	movqi_insn/2	[length = 1]
 342 00e2 00D0      		rcall MotorSpeed	 ;  206	call_insn/2	[length = 1]
 343               	.LVL40:
 344 00e4 00EA      		ldi r16,lo8(-96)	 ;  312	*movhi/5	[length = 2]
 345 00e6 1FE0      		ldi r17,lo8(15)
 346 00e8 00C0      		rjmp .L33	 ;  401	jump	[length = 1]
 347               	.LVL41:
 348               	.L30:
 349               	.LBB31:
 350               	.LBB32:
 351               		.loc 2 346 0
 352 00ea 84E2      		ldi r24,lo8(36)	 ;  140	movqi_insn/2	[length = 1]
 353 00ec 00D0      		rcall sleep	 ;  141	call_insn/2	[length = 1]
 354               	.LVL42:
 355 00ee 0150      		subi r16,1	 ;  145	addhi3_clobber/2	[length = 2]
 356 00f0 1109      		sbc r17,__zero_reg__
 357               	.LVL43:
 345:../../libtinyasuro/inc/asuro/time.h ****         sleep(36);
 358               		.loc 2 345 0
 359 00f2 0115      		cp r16,__zero_reg__	 ;  146	*cmphi/2	[length = 2]
 360 00f4 1105      		cpc r17,__zero_reg__
 361 00f6 01F4      		brne .L30	 ;  147	branch	[length = 1]
 362 00f8 00C0      		rjmp .L51	 ;  405	jump	[length = 1]
 363               	.LVL44:
 364               	.L24:
 365               	.LBE32:
 366               	.LBE31:
  55:main.c        **** 			status = 2;
 367               		.loc 3 55 0
 368 00fa 6CE8      		ldi r22,lo8(-116)	 ;  156	movqi_insn/2	[length = 1]
 369 00fc 80E5      		ldi r24,lo8(80)	 ;  157	movqi_insn/2	[length = 1]
 370 00fe 00D0      		rcall MotorSpeed	 ;  158	call_insn/2	[length = 1]
 371               	.LVL45:
 372 0100 00EA      		ldi r16,lo8(-96)	 ;  308	*movhi/5	[length = 2]
 373 0102 1FE0      		ldi r17,lo8(15)
 374               	.LVL46:
 375               	.L31:
 376               	.LBB33:
 377               	.LBB34:
 378               		.loc 2 346 0
 379 0104 84E2      		ldi r24,lo8(36)	 ;  164	movqi_insn/2	[length = 1]
 380 0106 00D0      		rcall sleep	 ;  165	call_insn/2	[length = 1]
 381               	.LVL47:
 382 0108 0150      		subi r16,1	 ;  169	addhi3_clobber/2	[length = 2]
 383 010a 1109      		sbc r17,__zero_reg__
 384               	.LVL48:
 345:../../libtinyasuro/inc/asuro/time.h ****         sleep(36);
 385               		.loc 2 345 0
 386 010c 0115      		cp r16,__zero_reg__	 ;  170	*cmphi/2	[length = 2]
 387 010e 1105      		cpc r17,__zero_reg__
 388 0110 01F4      		brne .L31	 ;  171	branch	[length = 1]
 389 0112 00C0      		rjmp .L52	 ;  409	jump	[length = 1]
 390               	.LVL49:
 391               	.L27:
 392               	.LBE34:
 393               	.LBE33:
  61:main.c        **** 			status = 3;
 394               		.loc 3 61 0
 395 0114 6DEC      		ldi r22,lo8(-51)	 ;  180	movqi_insn/2	[length = 1]
 396 0116 8CED      		ldi r24,lo8(-36)	 ;  181	movqi_insn/2	[length = 1]
 397 0118 00D0      		rcall MotorSpeed	 ;  182	call_insn/2	[length = 1]
 398               	.LVL50:
 399 011a 00EA      		ldi r16,lo8(-96)	 ;  310	*movhi/5	[length = 2]
 400 011c 1FE0      		ldi r17,lo8(15)
 401               	.LVL51:
 402               	.L32:
 403               	.LBB35:
 404               	.LBB36:
 405               		.loc 2 346 0
 406 011e 84E2      		ldi r24,lo8(36)	 ;  188	movqi_insn/2	[length = 1]
 407 0120 00D0      		rcall sleep	 ;  189	call_insn/2	[length = 1]
 408               	.LVL52:
 409 0122 0150      		subi r16,1	 ;  193	addhi3_clobber/2	[length = 2]
 410 0124 1109      		sbc r17,__zero_reg__
 411               	.LVL53:
 345:../../libtinyasuro/inc/asuro/time.h ****         sleep(36);
 412               		.loc 2 345 0
 413 0126 0115      		cp r16,__zero_reg__	 ;  194	*cmphi/2	[length = 2]
 414 0128 1105      		cpc r17,__zero_reg__
 415 012a 01F4      		brne .L32	 ;  195	branch	[length = 1]
 416 012c 00C0      		rjmp .L53	 ;  413	jump	[length = 1]
 417               	.LVL54:
 418               	.L33:
 419               	.LBE36:
 420               	.LBE35:
 421               	.LBB37:
 422               	.LBB38:
 423               		.loc 2 346 0
 424 012e 84E2      		ldi r24,lo8(36)	 ;  212	movqi_insn/2	[length = 1]
 425 0130 00D0      		rcall sleep	 ;  213	call_insn/2	[length = 1]
 426               	.LVL55:
 427 0132 0150      		subi r16,1	 ;  217	addhi3_clobber/2	[length = 2]
 428 0134 1109      		sbc r17,__zero_reg__
 429               	.LVL56:
 345:../../libtinyasuro/inc/asuro/time.h ****         sleep(36);
 430               		.loc 2 345 0
 431 0136 0115      		cp r16,__zero_reg__	 ;  218	*cmphi/2	[length = 2]
 432 0138 1105      		cpc r17,__zero_reg__
 433 013a 01F4      		brne .L33	 ;  219	branch	[length = 1]
 434 013c 00C0      		rjmp .L54	 ;  417	jump	[length = 1]
 435               	.LVL57:
 436               	.L23:
 437               	.LBE38:
 438               	.LBE37:
  68:main.c        **** 			status = 0;
  69:main.c        **** 			msleep(4000);
  70:main.c        **** 			break;
  71:main.c        **** 			
  72:main.c        **** 			default: 
  73:main.c        **** 			MotorDir(BREAK, BREAK);
 439               		.loc 3 73 0
 440 013e 60E0      		ldi r22,0	 ;  228	movqi_insn/1	[length = 1]
 441 0140 80E0      		ldi r24,0	 ;  229	movqi_insn/1	[length = 1]
 442 0142 00D0      		rcall MotorDir	 ;  230	call_insn/2	[length = 1]
 443               	.LVL58:
 444 0144 00C0      		rjmp .L29	 ;  419	jump	[length = 1]
 445               	.LVL59:
 446               	.L51:
  50:main.c        **** 			msleep(4000);
 447               		.loc 3 50 0
 448 0146 01E0      		ldi r16,lo8(1)	 ;  314	*movhi/5	[length = 2]
 449 0148 10E0      		ldi r17,0
 450               	.LVL60:
 451 014a 00C0      		rjmp .L29	 ;  421	jump	[length = 1]
 452               	.LVL61:
 453               	.L52:
  56:main.c        **** 			msleep(4000);
 454               		.loc 3 56 0
 455 014c 02E0      		ldi r16,lo8(2)	 ;  309	*movhi/5	[length = 2]
 456 014e 10E0      		ldi r17,0
 457               	.LVL62:
 458 0150 00C0      		rjmp .L29	 ;  423	jump	[length = 1]
 459               	.LVL63:
 460               	.L53:
  62:main.c        **** 			msleep(4000);
 461               		.loc 3 62 0
 462 0152 03E0      		ldi r16,lo8(3)	 ;  311	*movhi/5	[length = 2]
 463 0154 10E0      		ldi r17,0
 464               	.LVL64:
 465 0156 00C0      		rjmp .L29	 ;  425	jump	[length = 1]
 466               	.LVL65:
 467               	.L54:
  68:main.c        **** 			msleep(4000);
 468               		.loc 3 68 0
 469 0158 00E0      		ldi r16,0	 ;  13	*movhi/2	[length = 2]
 470 015a 10E0      		ldi r17,0
 471               	.LVL66:
 472               	.L29:
  74:main.c        **** 		}
  75:main.c        **** 		
  76:main.c        **** 		int sstatus = 0;
  77:main.c        **** 		switch (sstatus)
  78:main.c        **** 		{
  79:main.c        **** 			case 0:
  80:main.c        **** 			StatusLED(RED);
 473               		.loc 3 80 0
 474 015c 82E0      		ldi r24,lo8(2)	 ;  235	movqi_insn/2	[length = 1]
 475 015e 00D0      		rcall StatusLED	 ;  236	call_insn/2	[length = 1]
 476               	.LVL67:
  81:main.c        **** 			sstatus = 1;
  82:main.c        **** 			break;
  83:main.c        **** 			
  84:main.c        **** 			case 1:
  85:main.c        **** 			StatusLED(GREEN);
  86:main.c        **** 			sstatus = 2;
  87:main.c        **** 			break;
  88:main.c        **** 			
  89:main.c        **** 			case 2:
  90:main.c        **** 			StatusLED(YELLOW);
  91:main.c        **** 			sstatus = 0;
  92:main.c        **** 			break;
  93:main.c        **** 		}
  94:main.c        **** 		BackLED(OFF, OFF);
 477               		.loc 3 94 0
 478 0160 60E0      		ldi r22,0	 ;  238	movqi_insn/1	[length = 1]
 479 0162 80E0      		ldi r24,0	 ;  239	movqi_insn/1	[length = 1]
 480 0164 00D0      		rcall BackLED	 ;  240	call_insn/2	[length = 1]
 481               	.LVL68:
 482 0166 84EF      		ldi r24,lo8(-12)	 ;  385	*reload_inhi	[length = 4]
 483 0168 C82E      		mov r12,r24
 484 016a DD24      		clr r13
 485 016c D394      		inc r13
 486               	.LVL69:
 487               	.L35:
 488               	.LBB39:
 489               	.LBB40:
 490               		.loc 2 346 0
 491 016e 84E2      		ldi r24,lo8(36)	 ;  245	movqi_insn/2	[length = 1]
 492 0170 00D0      		rcall sleep	 ;  246	call_insn/2	[length = 1]
 493               	.LVL70:
 494 0172 81E0      		ldi r24,1	 ;  250	addhi3_clobber/3	[length = 3]
 495 0174 C81A      		sub r12,r24
 496 0176 D108      		sbc r13,__zero_reg__
 497               	.LVL71:
 345:../../libtinyasuro/inc/asuro/time.h ****         sleep(36);
 498               		.loc 2 345 0
 499 0178 C114      		cp r12,__zero_reg__	 ;  251	*cmphi/2	[length = 2]
 500 017a D104      		cpc r13,__zero_reg__
 501 017c 01F4      		brne .L35	 ;  252	branch	[length = 1]
 502 017e 00C0      		rjmp .L36	 ;  428	jump	[length = 1]
 503               	.LBE40:
 504               	.LBE39:
 505               	.LBE26:
 506               		.cfi_endproc
 507               	.LFE10:
 509               		.text
 510               	.Letext0:
 511               		.file 4 "/usr/lib/avr/include/stdint.h"
 512               		.file 5 "../../libtinyasuro/inc/asuro/motor.h"
 513               		.file 6 "../../libtinyasuro/inc/asuro/led.h"
 514               		.file 7 "/usr/lib/avr/include/stdlib.h"
 515               		.file 8 "../../libtinyasuro/inc/asuro/switches.h"
 516               		.file 9 "../../libtinyasuro/inc/asuro/sensors.h"
 517               		.file 10 "../../libtinyasuro/inc/asuro/asuro.h"
DEFINED SYMBOLS
                            *ABS*:00000000 main.c
     /tmp/ccPtNM0G.s:2      *ABS*:0000003e __SP_H__
     /tmp/ccPtNM0G.s:3      *ABS*:0000003d __SP_L__
     /tmp/ccPtNM0G.s:4      *ABS*:0000003f __SREG__
     /tmp/ccPtNM0G.s:5      *ABS*:00000000 __tmp_reg__
     /tmp/ccPtNM0G.s:6      *ABS*:00000001 __zero_reg__
     /tmp/ccPtNM0G.s:13     .text.stopAsuro:00000000 stopAsuro
     /tmp/ccPtNM0G.s:71     .text.flashLED:00000000 flashLED
     /tmp/ccPtNM0G.s:116    .text.stopLED:00000000 stopLED
     /tmp/ccPtNM0G.s:134    .text.startup.main:00000000 main

UNDEFINED SYMBOLS
MotorSpeed
sleep
StatusLED
Init
PollSwitch
MotorDir
LineData
__divmodhi4
rand
BackLED
