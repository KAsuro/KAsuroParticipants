   1               		.file	"main.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   7               		.text
   8               	.Ltext0:
   9               		.cfi_sections	.debug_frame
  10               		.section	.text.startup.main,"ax",@progbits
  11               	.global	main
  13               	main:
  14               	.LFB2:
  15               		.file 1 "main.c"
   1:main.c        **** 	
   2:main.c        **** // 	   			(K)iT lives!
   3:main.c        **** //*********************************************
   4:main.c        **** //*|x|**| |***| |****[___]****[_________]**|x|*
   5:main.c        **** //*|x|**| |***/ /*****| |*********| |******|x|*	 
   6:main.c        **** //*|x|**| |**/ /******| |*********| |******|x|*
   7:main.c        **** //*|x|**[     ]*******| |*********| |******|x|*
   8:main.c        **** //*|x|**| |**\ \******| |*********| |******|x|*
   9:main.c        **** //*|x|**| |***\ \*****| |*********| |******|x|*
  10:main.c        **** //*|x|**| |***| |****[___]*******[___]*****|x|*
  11:main.c        **** //*********************************************
  12:main.c        **** //
  13:main.c        **** #define SWITCH(X) 1<<X
  14:main.c        **** 
  15:main.c        **** 
  16:main.c        **** #include <asuro/asuro.h>
  17:main.c        **** 
  18:main.c        **** 
  19:main.c        **** 
  20:main.c        **** void main(void)		{
  16               		.loc 1 20 0
  17               		.cfi_startproc
  18 0000 CF93      		push r28	 ;  576	pushqi1/1	[length = 1]
  19               	.LCFI0:
  20               		.cfi_def_cfa_offset 3
  21               		.cfi_offset 28, -2
  22 0002 DF93      		push r29	 ;  577	pushqi1/1	[length = 1]
  23               	.LCFI1:
  24               		.cfi_def_cfa_offset 4
  25               		.cfi_offset 29, -3
  26 0004 CDB7      		in r28,__SP_L__	 ;  578	*movhi/8	[length = 2]
  27 0006 DEB7      		in r29,__SP_H__
  28               	.LCFI2:
  29               		.cfi_def_cfa_register 28
  30 0008 6B97      		sbiw r28,27	 ;  579	*addhi3/3	[length = 1]
  31               	.LCFI3:
  32               		.cfi_def_cfa_offset 31
  33 000a 0FB6      		in __tmp_reg__,__SREG__	 ;  580	movhi_sp_r/3	[length = 5]
  34 000c F894      		cli
  35 000e DEBF      		out __SP_H__,r29
  36 0010 0FBE      		out __SREG__,__tmp_reg__
  37 0012 CDBF      		out __SP_L__,r28
  38               	/* prologue: function */
  39               	/* frame size = 27 */
  40               	/* stack size = 29 */
  41               	.L__stack_usage = 29
  21:main.c        ****     Init();
  42               		.loc 1 21 0
  43 0014 00D0      		rcall Init	 ;  40	call_insn/2	[length = 1]
  44               	.LVL0:
  22:main.c        ****    
  23:main.c        **** 	MotorSpeed(0,0);
  45               		.loc 1 23 0
  46 0016 60E0      		ldi r22,0	 ;  41	movqi_insn/1	[length = 1]
  47 0018 80E0      		ldi r24,0	 ;  42	movqi_insn/1	[length = 1]
  48 001a 00D0      		rcall MotorSpeed	 ;  43	call_insn/2	[length = 1]
  49               	.LVL1:
  24:main.c        **** 	MotorDir(FREE,FREE);
  50               		.loc 1 24 0
  51 001c 60E3      		ldi r22,lo8(48)	 ;  44	movqi_insn/2	[length = 1]
  52 001e 80E3      		ldi r24,lo8(48)	 ;  45	movqi_insn/2	[length = 1]
  53 0020 00D0      		rcall MotorDir	 ;  46	call_insn/2	[length = 1]
  54               	.LVL2:
  25:main.c        **** 	FrontLED(OFF);
  55               		.loc 1 25 0
  56 0022 80E0      		ldi r24,0	 ;  47	movqi_insn/1	[length = 1]
  57 0024 00D0      		rcall FrontLED	 ;  48	call_insn/2	[length = 1]
  58               	.LVL3:
  26:main.c        **** 	BackLED(OFF,OFF);
  59               		.loc 1 26 0
  60 0026 60E0      		ldi r22,0	 ;  49	movqi_insn/1	[length = 1]
  61 0028 80E0      		ldi r24,0	 ;  50	movqi_insn/1	[length = 1]
  62 002a 00D0      		rcall BackLED	 ;  51	call_insn/2	[length = 1]
  63               	.LVL4:
  27:main.c        **** 	StatusLED(OFF);
  64               		.loc 1 27 0
  65 002c 80E0      		ldi r24,0	 ;  52	movqi_insn/1	[length = 1]
  66 002e 00D0      		rcall StatusLED	 ;  53	call_insn/2	[length = 1]
  67               	.LVL5:
  28:main.c        **** 	
  29:main.c        ****     
  30:main.c        ****     int pressed[]	= {0,0,0,0,0,0,0,0,0,0,0};
  68               		.loc 1 30 0
  69 0030 CE01      		movw r24,r28	 ;  567	*movhi/1	[length = 1]
  70 0032 0196      		adiw r24,1	 ;  487	*addhi3/3	[length = 1]
  71 0034 3C01      		movw r6,r24	 ;  568	*movhi/1	[length = 1]
  72 0036 86E1      		ldi r24,lo8(22)	 ;  564	movqi_insn/2	[length = 1]
  73 0038 F301      		movw r30,r6	 ;  569	*movhi/1	[length = 1]
  74               		0:	 ;  56	*clrmemqi	[length = 3]
  75 003a 1192      		st Z+,__zero_reg__
  76 003c 8A95      		dec r24
  77 003e 01F4      		brne 0b
  78               	.LVL6:
  31:main.c        ****     int t			= 0;
  32:main.c        ****     int counter 	= 0;
  33:main.c        ****     int x			= 0;
  79               		.loc 1 33 0
  80 0040 E12C      		mov r14,__zero_reg__	 ;  22	*movhi/2	[length = 2]
  81 0042 F12C      		mov r15,__zero_reg__
  32:main.c        ****     int x			= 0;
  82               		.loc 1 32 0
  83 0044 A12C      		mov r10,__zero_reg__	 ;  23	*movhi/2	[length = 2]
  84 0046 B12C      		mov r11,__zero_reg__
  31:main.c        ****     int t			= 0;
  85               		.loc 1 31 0
  86 0048 C12C      		mov r12,__zero_reg__	 ;  24	*movhi/2	[length = 2]
  87 004a D12C      		mov r13,__zero_reg__
  88               	.LBB21:
  34:main.c        ****     int left 		= 0;
  35:main.c        ****     int right 		= 0;
  36:main.c        **** 	char a_pressed	= 0;
  37:main.c        **** 	char b_pressed	= 0;
  38:main.c        **** 	char c_pressed	= 0;
  39:main.c        **** 	char d_pressed	= 0;
  40:main.c        **** 	char e_pressed	= 0;
  41:main.c        **** 	char f_pressed	= 0;
  42:main.c        ****     
  43:main.c        **** 	while(1){
  44:main.c        **** 		
  45:main.c        **** 		
  46:main.c        **** 		uint16_t lineData[] = {0,0};
  47:main.c        **** 		LineData(lineData);
  48:main.c        **** 		
  49:main.c        **** 		char switches = PollSwitch();
  50:main.c        ****         switches &= 0b00111111;
  51:main.c        **** 		
  52:main.c        **** 		left  = ((int)lineData[LEFT] +160)  / 7;
  89               		.loc 1 52 0
  90 004c 47E0      		ldi r20,lo8(7)	 ;  586	*reload_inhi	[length = 3]
  91 004e 842E      		mov r8,r20
  92 0050 912C      		mov r9,__zero_reg__
  93               	.LVL7:
  94               	.L34:
  46:main.c        **** 		LineData(lineData);
  95               		.loc 1 46 0
  96 0052 188E      		std Y+24,__zero_reg__	 ;  511	*movhi/4	[length = 2]
  97 0054 1F8A      		std Y+23,__zero_reg__
  98 0056 1A8E      		std Y+26,__zero_reg__	 ;  512	*movhi/4	[length = 2]
  99 0058 198E      		std Y+25,__zero_reg__
  47:main.c        **** 		
 100               		.loc 1 47 0
 101 005a CE01      		movw r24,r28	 ;  570	*movhi/1	[length = 1]
 102 005c 4796      		adiw r24,23	 ;  75	*addhi3/3	[length = 1]
 103 005e 00D0      		rcall LineData	 ;  76	call_insn/2	[length = 1]
 104               	.LVL8:
  49:main.c        ****         switches &= 0b00111111;
 105               		.loc 1 49 0
 106 0060 00D0      		rcall PollSwitch	 ;  77	call_value_insn/2	[length = 1]
 107               	.LVL9:
 108 0062 8B8F      		std Y+27,r24	 ;  78	movqi_insn/3	[length = 1]
 109               	.LVL10:
 110               		.loc 1 52 0
 111 0064 8F89      		ldd r24,Y+23	 ;  81	*movhi/3	[length = 2]
 112 0066 988D      		ldd r25,Y+24
 113               	.LVL11:
 114 0068 8056      		subi r24,96	 ;  82	addhi3_clobber/2	[length = 2]
 115 006a 9F4F      		sbci r25,-1
 116 006c B401      		movw r22,r8	 ;  555	*movhi/1	[length = 1]
 117 006e 00D0      		rcall __divmodhi4	 ;  556	*divmodhi4_call	[length = 1]
 118 0070 8B01      		movw r16,r22	 ;  557	*movhi/1	[length = 1]
 119               	.LVL12:
  53:main.c        **** 		right = ((int)lineData[RIGHT]+100)  / 7;
 120               		.loc 1 53 0
 121 0072 898D      		ldd r24,Y+25	 ;  87	*movhi/3	[length = 2]
 122 0074 9A8D      		ldd r25,Y+26
 123 0076 8C59      		subi r24,-100	 ;  88	addhi3_clobber/2	[length = 2]
 124 0078 9F4F      		sbci r25,-1
 125 007a B401      		movw r22,r8	 ;  560	*movhi/1	[length = 1]
 126 007c 00D0      		rcall __divmodhi4	 ;  561	*divmodhi4_call	[length = 1]
 127 007e 1B01      		movw r2,r22	 ;  562	*movhi/1	[length = 1]
 128 0080 2B01      		movw r4,r22	 ;  91	*movhi/1	[length = 1]
 129               	.LVL13:
  54:main.c        **** 		
  55:main.c        **** 		a_pressed = ( switches & SWITCH(1) );
  56:main.c        **** 		b_pressed = ( switches & SWITCH(4) );
  57:main.c        **** 		c_pressed = ( switches & SWITCH(0) );
  58:main.c        **** 		d_pressed = ( switches & SWITCH(3) );
  59:main.c        **** 		e_pressed = ( switches & SWITCH(2) );
  60:main.c        **** 		f_pressed = ( switches & SWITCH(5) );
  61:main.c        **** 		
  62:main.c        **** 		//fahren
  63:main.c        **** 		
  64:main.c        **** 		if (left>200 ){
 130               		.loc 1 64 0
 131 0082 093C      		cpi r16,-55	 ;  99	*cmphi/6	[length = 2]
 132 0084 1105      		cpc r17,__zero_reg__
 133 0086 04F4      		brge .L35	 ;  100	branch	[length = 1]
  65:main.c        **** 			left=200;
  66:main.c        **** 		}
  67:main.c        **** 		else if(left<100){
 134               		.loc 1 67 0
 135 0088 0436      		cpi r16,100	 ;  102	*cmphi/6	[length = 2]
 136 008a 1105      		cpc r17,__zero_reg__
 137 008c 04F4      		brge .L2	 ;  103	branch	[length = 1]
 138               	.LVL14:
  68:main.c        **** 			left=0;
  69:main.c        **** 			StatusLED(RED);
 139               		.loc 1 69 0
 140 008e 82E0      		ldi r24,lo8(2)	 ;  106	movqi_insn/2	[length = 1]
 141 0090 00D0      		rcall StatusLED	 ;  107	call_insn/2	[length = 1]
 142               	.LVL15:
  68:main.c        **** 			left=0;
 143               		.loc 1 68 0
 144 0092 00E0      		ldi r16,0	 ;  516	*movhi/2	[length = 2]
 145 0094 10E0      		ldi r17,0
 146 0096 00C0      		rjmp .L2	 ;  589	jump	[length = 1]
 147               	.LVL16:
 148               	.L35:
  65:main.c        **** 			left=200;
 149               		.loc 1 65 0
 150 0098 08EC      		ldi r16,lo8(-56)	 ;  515	*movhi/5	[length = 2]
 151 009a 10E0      		ldi r17,0
 152               	.LVL17:
 153               	.L2:
  70:main.c        **** 		}
  71:main.c        **** 				
  72:main.c        **** 		if (right>200){
 154               		.loc 1 72 0
 155 009c F9EC      		ldi r31,-55	 ;  111	*cmphi/7	[length = 3]
 156 009e 2F16      		cp r2,r31
 157 00a0 3104      		cpc r3,__zero_reg__
 158 00a2 04F4      		brge .L36	 ;  112	branch	[length = 1]
  73:main.c        **** 			(right=200);
  74:main.c        **** 		}
  75:main.c        **** 		
  76:main.c        **** 		else if(right<100){
 159               		.loc 1 76 0
 160 00a4 24E6      		ldi r18,100	 ;  114	*cmphi/7	[length = 3]
 161 00a6 2216      		cp r2,r18
 162 00a8 3104      		cpc r3,__zero_reg__
 163 00aa 04F4      		brge .L3	 ;  115	branch	[length = 1]
 164               	.LVL18:
  77:main.c        **** 			right=0;
  78:main.c        **** 			StatusLED(RED);
 165               		.loc 1 78 0
 166 00ac 82E0      		ldi r24,lo8(2)	 ;  118	movqi_insn/2	[length = 1]
 167 00ae 00D0      		rcall StatusLED	 ;  119	call_insn/2	[length = 1]
 168               	.LVL19:
  77:main.c        **** 			right=0;
 169               		.loc 1 77 0
 170 00b0 412C      		mov r4,__zero_reg__	 ;  518	*movhi/2	[length = 2]
 171 00b2 512C      		mov r5,__zero_reg__
 172 00b4 00C0      		rjmp .L3	 ;  591	jump	[length = 1]
 173               	.LVL20:
 174               	.L36:
  73:main.c        **** 			(right=200);
 175               		.loc 1 73 0
 176 00b6 38EC      		ldi r19,lo8(-56)	 ;  585	*reload_inhi	[length = 3]
 177 00b8 432E      		mov r4,r19
 178 00ba 512C      		mov r5,__zero_reg__
 179               	.LVL21:
 180               	.L3:
  79:main.c        **** 		}
  80:main.c        **** 			
  81:main.c        **** 		MotorDir(FWD,FWD);
 181               		.loc 1 81 0
 182 00bc 60E2      		ldi r22,lo8(32)	 ;  123	movqi_insn/2	[length = 1]
 183 00be 80E2      		ldi r24,lo8(32)	 ;  124	movqi_insn/2	[length = 1]
 184 00c0 00D0      		rcall MotorDir	 ;  125	call_insn/2	[length = 1]
 185               	.LVL22:
  82:main.c        **** 		MotorSpeed(right,left);
 186               		.loc 1 82 0
 187 00c2 602F      		mov r22,r16	 ;  126	movqi_insn/1	[length = 1]
 188 00c4 842D      		mov r24,r4	 ;  127	movqi_insn/1	[length = 1]
 189 00c6 00D0      		rcall MotorSpeed	 ;  128	call_insn/2	[length = 1]
 190               	.LVL23:
 191 00c8 28E7      		ldi r18,lo8(120)	 ;  584	*reload_inhi	[length = 3]
 192 00ca 222E      		mov r2,r18
 193 00cc 312C      		mov r3,__zero_reg__
 194               	.LVL24:
 195               	.L5:
 196               	.LBB22:
 197               	.LBB23:
 198               		.file 2 "../../libtinyasuro/inc/asuro/time.h"
   1:../../libtinyasuro/inc/asuro/time.h **** /**
   2:../../libtinyasuro/inc/asuro/time.h ****  * @file
   3:../../libtinyasuro/inc/asuro/time.h ****  *
   4:../../libtinyasuro/inc/asuro/time.h ****  * \if de
   5:../../libtinyasuro/inc/asuro/time.h ****  * Definiert die Schnittstelle für die Verwendung des Timer2 als gemeinsame
   6:../../libtinyasuro/inc/asuro/time.h ****  * Zeitbasis und Taktquelle.
   7:../../libtinyasuro/inc/asuro/time.h ****  *
   8:../../libtinyasuro/inc/asuro/time.h ****  * Es werden Funktionen definiert, die es ermöglichen, den Prozessor für einen
   9:../../libtinyasuro/inc/asuro/time.h ****  * definierten Zeitraum oder bis zum nächsten Interrupt in den Idle-Mode zu
  10:../../libtinyasuro/inc/asuro/time.h ****  * versetzen (unter Verwendung der Funktionalität aus avr/sleep.h).
  11:../../libtinyasuro/inc/asuro/time.h ****  *
  12:../../libtinyasuro/inc/asuro/time.h ****  * Außerdem wird die Möglichkeit geboten, die Taktausgabe für die
  13:../../libtinyasuro/inc/asuro/time.h ****  * IR-Schnittstelle ein- und auszuschalten.
  14:../../libtinyasuro/inc/asuro/time.h ****  *
  15:../../libtinyasuro/inc/asuro/time.h ****  * Zusätzlich besteht die Möglichkeit, eine eigene Funktion in der mit 36kHz
  16:../../libtinyasuro/inc/asuro/time.h ****  * aufgerufenen Timer2-ISR auszuführen, sofern diese Option in hooks.h aktiviert
  17:../../libtinyasuro/inc/asuro/time.h ****  * ist.
  18:../../libtinyasuro/inc/asuro/time.h ****  *
  19:../../libtinyasuro/inc/asuro/time.h ****  * @par Wichtiger Hinweis:
  20:../../libtinyasuro/inc/asuro/time.h ****  *      Für eine korrekte Funktion des Moduls müssen Interrupts global
  21:../../libtinyasuro/inc/asuro/time.h ****  *      freigeschaltet sein, Ausnahmen sind für kurze Zeitspannen zulässig,
  22:../../libtinyasuro/inc/asuro/time.h ****  *      können aber die Genauigkeit negativ beeinflussen.
  23:../../libtinyasuro/inc/asuro/time.h ****  *
  24:../../libtinyasuro/inc/asuro/time.h ****  * @par Initialisierung:
  25:../../libtinyasuro/inc/asuro/time.h ****  *      Vor der Verwendung des Moduls muss Timer2Init() aufgerufen werden, zudem
  26:../../libtinyasuro/inc/asuro/time.h ****  *      wird eine globale Interruptfreigabe benötigt.
  27:../../libtinyasuro/inc/asuro/time.h ****  *
  28:../../libtinyasuro/inc/asuro/time.h ****  * @par Genutzte Hardwareressourcen:
  29:../../libtinyasuro/inc/asuro/time.h ****  *      Module:
  30:../../libtinyasuro/inc/asuro/time.h ****  *      @li Timer2
  31:../../libtinyasuro/inc/asuro/time.h ****  *
  32:../../libtinyasuro/inc/asuro/time.h ****  *      Interruptvektoren:
  33:../../libtinyasuro/inc/asuro/time.h ****  *      @li TIMER2_OVF
  34:../../libtinyasuro/inc/asuro/time.h ****  *
  35:../../libtinyasuro/inc/asuro/time.h ****  *      I/O:
  36:../../libtinyasuro/inc/asuro/time.h ****  *      @li Port B: Pin 3 (36kHz-Träger der IR-Schnittstelle)
  37:../../libtinyasuro/inc/asuro/time.h ****  * \endif
  38:../../libtinyasuro/inc/asuro/time.h ****  *
  39:../../libtinyasuro/inc/asuro/time.h ****  * \if en
  40:../../libtinyasuro/inc/asuro/time.h ****  * Interface definitions to use timer2 as common clock source and time
  41:../../libtinyasuro/inc/asuro/time.h ****  * reference.
  42:../../libtinyasuro/inc/asuro/time.h ****  *
  43:../../libtinyasuro/inc/asuro/time.h ****  * This interface defines functions to put the microcontroller into idle mode
  44:../../libtinyasuro/inc/asuro/time.h ****  * for either a defined timespan or until the next interrupt occurs. The
  45:../../libtinyasuro/inc/asuro/time.h ****  * functionality in avr/sleep.h is used for this purpose.
  46:../../libtinyasuro/inc/asuro/time.h ****  *
  47:../../libtinyasuro/inc/asuro/time.h ****  * The carrier clock for the IR communications interface can be controlled
  48:../../libtinyasuro/inc/asuro/time.h ****  * using this interface.
  49:../../libtinyasuro/inc/asuro/time.h ****  *
  50:../../libtinyasuro/inc/asuro/time.h ****  * Timer2 is operating with a frequency of 36kHz, custom code can be executed
  51:../../libtinyasuro/inc/asuro/time.h ****  * by an ISR of timer2 if this feature is enabled in hooks.h.
  52:../../libtinyasuro/inc/asuro/time.h ****  *
  53:../../libtinyasuro/inc/asuro/time.h ****  * @par Important:
  54:../../libtinyasuro/inc/asuro/time.h ****  *      This module requires interrupts to be enabled globally. Short term
  55:../../libtinyasuro/inc/asuro/time.h ****  *      exceptions may be permittable but can have a negative effect on the
  56:../../libtinyasuro/inc/asuro/time.h ****  *      accuracy of the provided clock.
  57:../../libtinyasuro/inc/asuro/time.h ****  *
  58:../../libtinyasuro/inc/asuro/time.h ****  * @par Initialization:
  59:../../libtinyasuro/inc/asuro/time.h ****  *      Timer2Init() must be called before using this module. Interrupts must be
  60:../../libtinyasuro/inc/asuro/time.h ****  *      enabled globally.
  61:../../libtinyasuro/inc/asuro/time.h ****  *
  62:../../libtinyasuro/inc/asuro/time.h ****  * @par Hardware resources in use:
  63:../../libtinyasuro/inc/asuro/time.h ****  *      Components:
  64:../../libtinyasuro/inc/asuro/time.h ****  *      @li Timer2
  65:../../libtinyasuro/inc/asuro/time.h ****  *
  66:../../libtinyasuro/inc/asuro/time.h ****  *      Interrupt vectors:
  67:../../libtinyasuro/inc/asuro/time.h ****  *      @li TIMER2_OVF
  68:../../libtinyasuro/inc/asuro/time.h ****  *
  69:../../libtinyasuro/inc/asuro/time.h ****  *      I/O:
  70:../../libtinyasuro/inc/asuro/time.h ****  *      @li Port B: Pin 3 (36kHz carrier signal for IR communications)
  71:../../libtinyasuro/inc/asuro/time.h ****  * \endif
  72:../../libtinyasuro/inc/asuro/time.h ****  *
  73:../../libtinyasuro/inc/asuro/time.h ****  * @see hooks.h
  74:../../libtinyasuro/inc/asuro/time.h ****  *
  75:../../libtinyasuro/inc/asuro/time.h ****  * @author Markus Jung
  76:../../libtinyasuro/inc/asuro/time.h ****  *
  77:../../libtinyasuro/inc/asuro/time.h ****  * @version 23.05.2010 \n
  78:../../libtinyasuro/inc/asuro/time.h ****  *  Schnittstellendefinition entsprechend asuro.h
  79:../../libtinyasuro/inc/asuro/time.h ****  * @version 28.05.2010 \n
  80:../../libtinyasuro/inc/asuro/time.h ****  *  Zählervariable zugänglich gemacht
  81:../../libtinyasuro/inc/asuro/time.h ****  * @version 02.06.2010 \n
  82:../../libtinyasuro/inc/asuro/time.h ****  *  sleepUntilInterrupt implementiert
  83:../../libtinyasuro/inc/asuro/time.h ****  * @version 15.06.2010 \n
  84:../../libtinyasuro/inc/asuro/time.h ****  *  Doku
  85:../../libtinyasuro/inc/asuro/time.h ****  * @version 26.06.2010 \n
  86:../../libtinyasuro/inc/asuro/time.h ****  *  Alias-Makros für sleep, msleep und sleepUntilInterrupt hinzugefügt
  87:../../libtinyasuro/inc/asuro/time.h ****  *  (zwecks konsistentem Namensschema)
  88:../../libtinyasuro/inc/asuro/time.h ****  * @version 16.08.2010 \n
  89:../../libtinyasuro/inc/asuro/time.h ****  *  + Hook für Timer2ISR
  90:../../libtinyasuro/inc/asuro/time.h ****  * @version 13.09.2013 \n
  91:../../libtinyasuro/inc/asuro/time.h ****  *  English documentation
  92:../../libtinyasuro/inc/asuro/time.h ****  * @version 29.10.2013 \n
  93:../../libtinyasuro/inc/asuro/time.h ****  *  Document interrupt safety issues of TIMER2_CLOCK_OUT_ENABLE() and
  94:../../libtinyasuro/inc/asuro/time.h ****  *  TIMER2_CLOCK_OUT_DISABLE()
  95:../../libtinyasuro/inc/asuro/time.h ****  */
  96:../../libtinyasuro/inc/asuro/time.h **** /*
  97:../../libtinyasuro/inc/asuro/time.h ****  * The contents of this file are subject to the terms of the Common Development
  98:../../libtinyasuro/inc/asuro/time.h ****  * and Distribution License Version 1.0 (the License).
  99:../../libtinyasuro/inc/asuro/time.h ****  * You may not use this file except in compliance with the License.
 100:../../libtinyasuro/inc/asuro/time.h ****  *
 101:../../libtinyasuro/inc/asuro/time.h ****  * If not included, you can obtain a copy of the License at
 102:../../libtinyasuro/inc/asuro/time.h ****  * http://www.sun.com/cddl/cddl.html
 103:../../libtinyasuro/inc/asuro/time.h ****  *
 104:../../libtinyasuro/inc/asuro/time.h ****  * When distributing Covered Code, include this CDDL Header Notice in each file
 105:../../libtinyasuro/inc/asuro/time.h ****  * and include the provided License file.
 106:../../libtinyasuro/inc/asuro/time.h ****  */
 107:../../libtinyasuro/inc/asuro/time.h **** 
 108:../../libtinyasuro/inc/asuro/time.h **** #ifndef TIME_H_
 109:../../libtinyasuro/inc/asuro/time.h **** #define TIME_H_
 110:../../libtinyasuro/inc/asuro/time.h **** 
 111:../../libtinyasuro/inc/asuro/time.h **** #include <stdbool.h>
 112:../../libtinyasuro/inc/asuro/time.h **** #include <stdint.h>
 113:../../libtinyasuro/inc/asuro/time.h **** #include "hooks.h"
 114:../../libtinyasuro/inc/asuro/time.h **** #include "../util/misc.h"
 115:../../libtinyasuro/inc/asuro/time.h **** 
 116:../../libtinyasuro/inc/asuro/time.h **** #ifdef __DOXYGEN__
 117:../../libtinyasuro/inc/asuro/time.h **** /** \if de
 118:../../libtinyasuro/inc/asuro/time.h ****  * Alias-Makro für sleep().
 119:../../libtinyasuro/inc/asuro/time.h ****  * \endif
 120:../../libtinyasuro/inc/asuro/time.h ****  *
 121:../../libtinyasuro/inc/asuro/time.h ****  * \if en
 122:../../libtinyasuro/inc/asuro/time.h ****  * Alias macro for sleep().
 123:../../libtinyasuro/inc/asuro/time.h ****  * \endif
 124:../../libtinyasuro/inc/asuro/time.h ****  */
 125:../../libtinyasuro/inc/asuro/time.h **** #define Sleep
 126:../../libtinyasuro/inc/asuro/time.h **** /** \if de
 127:../../libtinyasuro/inc/asuro/time.h ****  * Alias-Makro für msleep().
 128:../../libtinyasuro/inc/asuro/time.h ****  * \endif
 129:../../libtinyasuro/inc/asuro/time.h ****  *
 130:../../libtinyasuro/inc/asuro/time.h ****  * \if en
 131:../../libtinyasuro/inc/asuro/time.h ****  * Alias macro for msleep().
 132:../../libtinyasuro/inc/asuro/time.h ****  * \endif
 133:../../libtinyasuro/inc/asuro/time.h ****  */
 134:../../libtinyasuro/inc/asuro/time.h **** #define Msleep
 135:../../libtinyasuro/inc/asuro/time.h **** /** \if de
 136:../../libtinyasuro/inc/asuro/time.h ****  * Alias-Makro für sleepUntilInterrupt().
 137:../../libtinyasuro/inc/asuro/time.h ****  * \endif
 138:../../libtinyasuro/inc/asuro/time.h ****  *
 139:../../libtinyasuro/inc/asuro/time.h ****  * \if en
 140:../../libtinyasuro/inc/asuro/time.h ****  * Alias macro for sleepUntilInterrupt().
 141:../../libtinyasuro/inc/asuro/time.h ****  * \endif
 142:../../libtinyasuro/inc/asuro/time.h ****  */
 143:../../libtinyasuro/inc/asuro/time.h **** #define SleepUntilInterrupt
 144:../../libtinyasuro/inc/asuro/time.h **** #else
 145:../../libtinyasuro/inc/asuro/time.h **** #define Sleep               sleep
 146:../../libtinyasuro/inc/asuro/time.h **** #define Msleep              msleep
 147:../../libtinyasuro/inc/asuro/time.h **** #define SleepUntilInterrupt sleepUntilInterrupt
 148:../../libtinyasuro/inc/asuro/time.h **** #endif
 149:../../libtinyasuro/inc/asuro/time.h **** 
 150:../../libtinyasuro/inc/asuro/time.h **** /**
 151:../../libtinyasuro/inc/asuro/time.h ****  * \if de
 152:../../libtinyasuro/inc/asuro/time.h ****  * Eine Zählvariable die im 36kHz-Takt (um eins) inkrementiert wird.
 153:../../libtinyasuro/inc/asuro/time.h ****  * \endif
 154:../../libtinyasuro/inc/asuro/time.h ****  *
 155:../../libtinyasuro/inc/asuro/time.h ****  * \if en
 156:../../libtinyasuro/inc/asuro/time.h ****  * A counting variable incremented from the 36kHz clock.
 157:../../libtinyasuro/inc/asuro/time.h ****  * \endif
 158:../../libtinyasuro/inc/asuro/time.h ****  */
 159:../../libtinyasuro/inc/asuro/time.h **** extern volatile uint8_t tick36kHz; // counts from 0 to 255
 160:../../libtinyasuro/inc/asuro/time.h **** 
 161:../../libtinyasuro/inc/asuro/time.h **** #ifdef __DOXYGEN__
 162:../../libtinyasuro/inc/asuro/time.h **** /**
 163:../../libtinyasuro/inc/asuro/time.h ****  * \if de
 164:../../libtinyasuro/inc/asuro/time.h ****  * Bietet die Möglichkeit, eine eigene Funktion bei jedem Aufruf der Timer-ISR
 165:../../libtinyasuro/inc/asuro/time.h ****  * auszuführen. Die interne Funktionalität bleibt dabei erhalten.
 166:../../libtinyasuro/inc/asuro/time.h ****  *
 167:../../libtinyasuro/inc/asuro/time.h ****  * Da die Timer-ISR mit einer Frequenz von 36kHz aufgerufen wird, sollte diese
 168:../../libtinyasuro/inc/asuro/time.h ****  * Funktion möglichst kurz sein.
 169:../../libtinyasuro/inc/asuro/time.h ****  *
 170:../../libtinyasuro/inc/asuro/time.h ****  * Der Aufruf erfolgt aus dem Kontext eines Interrupts!
 171:../../libtinyasuro/inc/asuro/time.h ****  *
 172:../../libtinyasuro/inc/asuro/time.h ****  * Ist (Timer2ISRHook == NULL), findet kein Aufruf statt.
 173:../../libtinyasuro/inc/asuro/time.h ****  *
 174:../../libtinyasuro/inc/asuro/time.h ****  * Diese Funktionalität steht nicht zur Verfügung, wenn TIMER2_ISR_HOOK_ENABLE
 175:../../libtinyasuro/inc/asuro/time.h ****  * deaktiviert ist.
 176:../../libtinyasuro/inc/asuro/time.h ****  * \endif
 177:../../libtinyasuro/inc/asuro/time.h ****  *
 178:../../libtinyasuro/inc/asuro/time.h ****  * \if en
 179:../../libtinyasuro/inc/asuro/time.h ****  * Offers the ability to execute a custom function in addition to the internal
 180:../../libtinyasuro/inc/asuro/time.h ****  * code of the timer ISR.
 181:../../libtinyasuro/inc/asuro/time.h ****  *
 182:../../libtinyasuro/inc/asuro/time.h ****  * Since the ISR will be executed with a frequency of 36kHz, the called function
 183:../../libtinyasuro/inc/asuro/time.h ****  * should be as short as possible.
 184:../../libtinyasuro/inc/asuro/time.h ****  *
 185:../../libtinyasuro/inc/asuro/time.h ****  * The function will be called from an interrupt context!
 186:../../libtinyasuro/inc/asuro/time.h ****  *
 187:../../libtinyasuro/inc/asuro/time.h ****  * No function call will be executed if (Timer2ISRHook == NULL).
 188:../../libtinyasuro/inc/asuro/time.h ****  *
 189:../../libtinyasuro/inc/asuro/time.h ****  * The timer hook feature is not available if TIMER2_ISR_HOOK_ENABLE has been
 190:../../libtinyasuro/inc/asuro/time.h ****  * disabled.
 191:../../libtinyasuro/inc/asuro/time.h ****  * \endif
 192:../../libtinyasuro/inc/asuro/time.h ****  */
 193:../../libtinyasuro/inc/asuro/time.h **** extern ISRHookFunc_t *Timer2ISRHook;
 194:../../libtinyasuro/inc/asuro/time.h **** #else  // !__DOXYGEN__
 195:../../libtinyasuro/inc/asuro/time.h **** #if TIMER2_ISR_HOOK_ENABLE
 196:../../libtinyasuro/inc/asuro/time.h **** extern ISRHookFunc_t *Timer2ISRHook;
 197:../../libtinyasuro/inc/asuro/time.h **** #endif
 198:../../libtinyasuro/inc/asuro/time.h **** #endif
 199:../../libtinyasuro/inc/asuro/time.h **** 
 200:../../libtinyasuro/inc/asuro/time.h **** /**
 201:../../libtinyasuro/inc/asuro/time.h ****  * \if de
 202:../../libtinyasuro/inc/asuro/time.h ****  * Initialisiert das Modul und den als Zeitbasis und Taktgenerator für die
 203:../../libtinyasuro/inc/asuro/time.h ****  * Infrarotschnittstelle verwendeten Timer2.
 204:../../libtinyasuro/inc/asuro/time.h ****  *
 205:../../libtinyasuro/inc/asuro/time.h ****  * Nach der Initialisierung ist die Taktausgabe für die Infrarotschnittstelle
 206:../../libtinyasuro/inc/asuro/time.h ****  * deaktiviert.
 207:../../libtinyasuro/inc/asuro/time.h ****  * \endif
 208:../../libtinyasuro/inc/asuro/time.h ****  *
 209:../../libtinyasuro/inc/asuro/time.h ****  * \if en
 210:../../libtinyasuro/inc/asuro/time.h ****  * Initializes the module and timer2 which is used as time reference and clock
 211:../../libtinyasuro/inc/asuro/time.h ****  * source for the IR communications interface.
 212:../../libtinyasuro/inc/asuro/time.h ****  *
 213:../../libtinyasuro/inc/asuro/time.h ****  * The clock output for the IR interface will be in a disabled state after the
 214:../../libtinyasuro/inc/asuro/time.h ****  * initialization has been completed.
 215:../../libtinyasuro/inc/asuro/time.h ****  * \endif
 216:../../libtinyasuro/inc/asuro/time.h ****  */
 217:../../libtinyasuro/inc/asuro/time.h **** extern void Timer2Init(void);
 218:../../libtinyasuro/inc/asuro/time.h **** 
 219:../../libtinyasuro/inc/asuro/time.h **** /**
 220:../../libtinyasuro/inc/asuro/time.h ****  * \if de
 221:../../libtinyasuro/inc/asuro/time.h ****  * Aktiviert die Ausgabe des 36kHz-Signals für die Infrarotschnittstelle.
 222:../../libtinyasuro/inc/asuro/time.h ****  *
 223:../../libtinyasuro/inc/asuro/time.h ****  * @par Wichtiger Hinweis:
 224:../../libtinyasuro/inc/asuro/time.h ****  * Dieses Makro ist nur eingeschänkt interruptfest. Es darf nicht "parallel" zu
 225:../../libtinyasuro/inc/asuro/time.h ****  * TIMER2_CLOCK_OUT_DISABLE() ausgeführt werden.
 226:../../libtinyasuro/inc/asuro/time.h ****  * \endif
 227:../../libtinyasuro/inc/asuro/time.h ****  *
 228:../../libtinyasuro/inc/asuro/time.h ****  * \if en
 229:../../libtinyasuro/inc/asuro/time.h ****  * Enables the 36kHz carrier signal for the IR communications interface.
 230:../../libtinyasuro/inc/asuro/time.h ****  *
 231:../../libtinyasuro/inc/asuro/time.h ****  * @par Important:
 232:../../libtinyasuro/inc/asuro/time.h ****  * This macro is interrupt-safe except for one restriction. It must not be
 233:../../libtinyasuro/inc/asuro/time.h ****  * executed in parallel to TIMER2_CLOCK_OUT_DISABLE().
 234:../../libtinyasuro/inc/asuro/time.h ****  * \endif
 235:../../libtinyasuro/inc/asuro/time.h ****  */
 236:../../libtinyasuro/inc/asuro/time.h **** #ifdef __DOXYGEN__
 237:../../libtinyasuro/inc/asuro/time.h **** #define TIMER2_CLOCK_OUT_ENABLE()
 238:../../libtinyasuro/inc/asuro/time.h **** #else
 239:../../libtinyasuro/inc/asuro/time.h **** #define TIMER2_CLOCK_OUT_ENABLE() \
 240:../../libtinyasuro/inc/asuro/time.h ****     do { /* Fast PWM, BOTTOM: Clear, CompMatch: Set */ \
 241:../../libtinyasuro/inc/asuro/time.h ****         TCCR2 |= (1 << WGM20) | (1 << WGM21) | (1 << COM20) | (1 << COM21); \
 242:../../libtinyasuro/inc/asuro/time.h ****     } while (false)
 243:../../libtinyasuro/inc/asuro/time.h **** #endif
 244:../../libtinyasuro/inc/asuro/time.h **** 
 245:../../libtinyasuro/inc/asuro/time.h **** /**
 246:../../libtinyasuro/inc/asuro/time.h ****  * \if de
 247:../../libtinyasuro/inc/asuro/time.h ****  * Deaktiviert die Ausgabe des 36kHz-Signals für die Infrarotschnittstelle.
 248:../../libtinyasuro/inc/asuro/time.h ****  *
 249:../../libtinyasuro/inc/asuro/time.h ****  * @par Wichtiger Hinweis:
 250:../../libtinyasuro/inc/asuro/time.h ****  * Dieses Makro ist nur eingeschränkt interruptfest. Es darf nicht "parallel"
 251:../../libtinyasuro/inc/asuro/time.h ****  * zu TIMER2_CLOCK_OUT_ENABLE() ausgeführt werden.
 252:../../libtinyasuro/inc/asuro/time.h ****  * \endif
 253:../../libtinyasuro/inc/asuro/time.h ****  *
 254:../../libtinyasuro/inc/asuro/time.h ****  * \if en
 255:../../libtinyasuro/inc/asuro/time.h ****  * Disables the 36kHz carrier signal for the IR communications interface.
 256:../../libtinyasuro/inc/asuro/time.h ****  *
 257:../../libtinyasuro/inc/asuro/time.h ****  * @par Important:
 258:../../libtinyasuro/inc/asuro/time.h ****  * This macro is interrupt-safe except for one restriction. It must not be
 259:../../libtinyasuro/inc/asuro/time.h ****  * executed in parallel to TIMER2_CLOCK_OUT_ENABLE().
 260:../../libtinyasuro/inc/asuro/time.h ****  * \endif
 261:../../libtinyasuro/inc/asuro/time.h ****  */
 262:../../libtinyasuro/inc/asuro/time.h **** #ifdef __DOXYGEN__
 263:../../libtinyasuro/inc/asuro/time.h **** #define TIMER2_CLOCK_OUT_DISABLE()
 264:../../libtinyasuro/inc/asuro/time.h **** #else
 265:../../libtinyasuro/inc/asuro/time.h **** #define TIMER2_CLOCK_OUT_DISABLE() \
 266:../../libtinyasuro/inc/asuro/time.h ****     do { /* PWM off */ \
 267:../../libtinyasuro/inc/asuro/time.h ****         TCCR2 &= ~((1 << WGM20) | (1 << WGM21) | (1 << COM20) | (1 << COM21)); \
 268:../../libtinyasuro/inc/asuro/time.h ****     } while (false)
 269:../../libtinyasuro/inc/asuro/time.h **** #endif
 270:../../libtinyasuro/inc/asuro/time.h **** 
 271:../../libtinyasuro/inc/asuro/time.h **** /**
 272:../../libtinyasuro/inc/asuro/time.h ****  * \if de
 273:../../libtinyasuro/inc/asuro/time.h ****  * Hält den Programmfluss für die vorgegebene Anzahl 36kHz-Takte an und schickt
 274:../../libtinyasuro/inc/asuro/time.h ****  * den Prozessor währendessen in den Idle-Mode.
 275:../../libtinyasuro/inc/asuro/time.h ****  *
 276:../../libtinyasuro/inc/asuro/time.h ****  * Alle Interrupts bleiben aktiv und werden ausgeführt, ledliglich der
 277:../../libtinyasuro/inc/asuro/time.h ****  * aufrufende Programmpfad wird unterbrochen.
 278:../../libtinyasuro/inc/asuro/time.h ****  *
 279:../../libtinyasuro/inc/asuro/time.h ****  * Wenn diese Funktion aufgerufen wird, geht sie davon aus, dass Interrupts
 280:../../libtinyasuro/inc/asuro/time.h ****  * global freigeschaltet sind - wenn nicht findet die globale Interruptfreigabe
 281:../../libtinyasuro/inc/asuro/time.h ****  * vor Eintritt in den Idle-Mode statt.
 282:../../libtinyasuro/inc/asuro/time.h ****  *
 283:../../libtinyasuro/inc/asuro/time.h ****  * @param timer36kHz_ticks die Anzahl der 36kHz-Takte die der Prozessor
 284:../../libtinyasuro/inc/asuro/time.h ****  *                         "schlafen" soll
 285:../../libtinyasuro/inc/asuro/time.h ****  * \endif
 286:../../libtinyasuro/inc/asuro/time.h ****  *
 287:../../libtinyasuro/inc/asuro/time.h ****  * \if en
 288:../../libtinyasuro/inc/asuro/time.h ****  * Delays the execution for the specified amount of time, measured in 36kHz
 289:../../libtinyasuro/inc/asuro/time.h ****  * ticks. The microcontroller will halted (idle mode) during this time.
 290:../../libtinyasuro/inc/asuro/time.h ****  *
 291:../../libtinyasuro/inc/asuro/time.h ****  * All interrupt requests remain active and will be executed, the calling
 292:../../libtinyasuro/inc/asuro/time.h ****  * function itself remains halted.
 293:../../libtinyasuro/inc/asuro/time.h ****  *
 294:../../libtinyasuro/inc/asuro/time.h ****  * This function expects interrupts to be globally enabled if it gets called.
 295:../../libtinyasuro/inc/asuro/time.h ****  * If not, the global interrupt enable bit will be set before entering the sleep
 296:../../libtinyasuro/inc/asuro/time.h ****  * mode and remain in this state after the function returns.
 297:../../libtinyasuro/inc/asuro/time.h ****  *
 298:../../libtinyasuro/inc/asuro/time.h ****  * @param timer36kHz_ticks the number of 36kHz ticks the microcontroller will
 299:../../libtinyasuro/inc/asuro/time.h ****  *                         be halted.
 300:../../libtinyasuro/inc/asuro/time.h ****  * \endif
 301:../../libtinyasuro/inc/asuro/time.h ****  */
 302:../../libtinyasuro/inc/asuro/time.h **** extern void sleep(uint8_t timer36kHz_ticks);
 303:../../libtinyasuro/inc/asuro/time.h **** /**
 304:../../libtinyasuro/inc/asuro/time.h ****  * \if de
 305:../../libtinyasuro/inc/asuro/time.h ****  * Schickt den Prozessor in den Idle-Mode und kehrt zurück, nachdem ein
 306:../../libtinyasuro/inc/asuro/time.h ****  * Interrupt ausgelöst wurde.
 307:../../libtinyasuro/inc/asuro/time.h ****  *
 308:../../libtinyasuro/inc/asuro/time.h ****  * Wenn diese Funktion aufgerufen wird, geht sie davon aus, dass Interrupts
 309:../../libtinyasuro/inc/asuro/time.h ****  * global freigeschaltet sind - wenn nicht findet die globale Interruptfreigabe
 310:../../libtinyasuro/inc/asuro/time.h ****  * vor Eintritt in den Idle-Mode statt.
 311:../../libtinyasuro/inc/asuro/time.h ****  * \endif
 312:../../libtinyasuro/inc/asuro/time.h ****  *
 313:../../libtinyasuro/inc/asuro/time.h ****  * \if en
 314:../../libtinyasuro/inc/asuro/time.h ****  * Puts the microcontroller into idle mode until the next interrupt occurs.
 315:../../libtinyasuro/inc/asuro/time.h ****  *
 316:../../libtinyasuro/inc/asuro/time.h ****  * This function expects interrupts to be globally enabled if it gets called.
 317:../../libtinyasuro/inc/asuro/time.h ****  * If not, the global interrupt enable bit will be set before entering the sleep
 318:../../libtinyasuro/inc/asuro/time.h ****  * mode and remain in this state after the function returns.
 319:../../libtinyasuro/inc/asuro/time.h ****  * \endif
 320:../../libtinyasuro/inc/asuro/time.h ****  */
 321:../../libtinyasuro/inc/asuro/time.h **** extern void sleepUntilInterrupt(void);
 322:../../libtinyasuro/inc/asuro/time.h **** 
 323:../../libtinyasuro/inc/asuro/time.h **** /**
 324:../../libtinyasuro/inc/asuro/time.h ****  * \if de
 325:../../libtinyasuro/inc/asuro/time.h ****  * Verhält sich wie sleep(), verwendet als Zeitbasis aber Millisekunden
 326:../../libtinyasuro/inc/asuro/time.h ****  *
 327:../../libtinyasuro/inc/asuro/time.h ****  * @param ms die Anzahl der Millisekunden die der Prozessor "schlafend"
 328:../../libtinyasuro/inc/asuro/time.h ****  *           verbringen soll
 329:../../libtinyasuro/inc/asuro/time.h ****  * \endif
 330:../../libtinyasuro/inc/asuro/time.h ****  *
 331:../../libtinyasuro/inc/asuro/time.h ****  * \if en
 332:../../libtinyasuro/inc/asuro/time.h ****  * Behaves like sleep() but uses milliseconds as timebase.
 333:../../libtinyasuro/inc/asuro/time.h ****  *
 334:../../libtinyasuro/inc/asuro/time.h ****  * @param ms the time the microcontroller will be halted, measured in
 335:../../libtinyasuro/inc/asuro/time.h ****  *           milliseconds
 336:../../libtinyasuro/inc/asuro/time.h ****  * \endif
 337:../../libtinyasuro/inc/asuro/time.h ****  */
 338:../../libtinyasuro/inc/asuro/time.h **** #ifdef __DOXYGEN__
 339:../../libtinyasuro/inc/asuro/time.h **** void msleep(uint16_t ms);
 340:../../libtinyasuro/inc/asuro/time.h **** #else
 341:../../libtinyasuro/inc/asuro/time.h **** static ALWAYS_INLINE void msleep(uint16_t ms);
 342:../../libtinyasuro/inc/asuro/time.h **** #endif
 343:../../libtinyasuro/inc/asuro/time.h **** 
 344:../../libtinyasuro/inc/asuro/time.h **** void msleep(uint16_t ms) {
 345:../../libtinyasuro/inc/asuro/time.h ****     for (; ms > 0; ms--) {
 346:../../libtinyasuro/inc/asuro/time.h ****         sleep(36);
 199               		.loc 2 346 0
 200 00ce 84E2      		ldi r24,lo8(36)	 ;  133	movqi_insn/2	[length = 1]
 201 00d0 00D0      		rcall sleep	 ;  134	call_insn/2	[length = 1]
 202               	.LVL25:
 203 00d2 81E0      		ldi r24,1	 ;  138	addhi3_clobber/3	[length = 3]
 204 00d4 281A      		sub r2,r24
 205 00d6 3108      		sbc r3,__zero_reg__
 206               	.LVL26:
 345:../../libtinyasuro/inc/asuro/time.h ****         sleep(36);
 207               		.loc 2 345 0
 208 00d8 2114      		cp r2,__zero_reg__	 ;  139	*cmphi/2	[length = 2]
 209 00da 3104      		cpc r3,__zero_reg__
 210 00dc 01F4      		brne .L5	 ;  140	branch	[length = 1]
 211               	.LBE23:
 212               	.LBE22:
  83:main.c        **** 		msleep(120);
  84:main.c        **** 						
  85:main.c        **** 		//LED Steuerung
  86:main.c        **** 		
  87:main.c        **** 		if(left > right){
 213               		.loc 1 87 0
 214 00de 4016      		cp r4,r16	 ;  149	*cmphi/3	[length = 2]
 215 00e0 5106      		cpc r5,r17
 216 00e2 04F4      		brge .L6	 ;  150	branch	[length = 1]
  88:main.c        **** 			BackLED(OFF,ON);
 217               		.loc 1 88 0
 218 00e4 61E0      		ldi r22,lo8(1)	 ;  152	movqi_insn/2	[length = 1]
 219 00e6 80E0      		ldi r24,0	 ;  153	movqi_insn/1	[length = 1]
 220 00e8 00D0      		rcall BackLED	 ;  154	call_insn/2	[length = 1]
 221               	.LVL27:
 222               	.L6:
  89:main.c        **** 		}
  90:main.c        **** 		
  91:main.c        **** 		if(right > left){
 223               		.loc 1 91 0
 224 00ea 0415      		cp r16,r4	 ;  157	*cmphi/3	[length = 2]
 225 00ec 1505      		cpc r17,r5
 226 00ee 04F4      		brge .L7	 ;  158	branch	[length = 1]
  92:main.c        **** 			BackLED(ON,OFF);
 227               		.loc 1 92 0
 228 00f0 60E0      		ldi r22,0	 ;  160	movqi_insn/1	[length = 1]
 229 00f2 81E0      		ldi r24,lo8(1)	 ;  161	movqi_insn/2	[length = 1]
 230 00f4 00D0      		rcall BackLED	 ;  162	call_insn/2	[length = 1]
 231               	.LVL28:
 232               	.L7:
  93:main.c        **** 		}
  94:main.c        **** 		
  95:main.c        **** 		if(right == left){
 233               		.loc 1 95 0
 234 00f6 4016      		cp r4,r16	 ;  165	*cmphi/3	[length = 2]
 235 00f8 5106      		cpc r5,r17
 236 00fa 01F4      		brne .L8	 ;  166	branch	[length = 1]
  96:main.c        **** 			BackLED(ON,ON);
 237               		.loc 1 96 0
 238 00fc 61E0      		ldi r22,lo8(1)	 ;  168	movqi_insn/2	[length = 1]
 239 00fe 81E0      		ldi r24,lo8(1)	 ;  169	movqi_insn/2	[length = 1]
 240 0100 00D0      		rcall BackLED	 ;  170	call_insn/2	[length = 1]
 241               	.LVL29:
 242               	.L8:
  97:main.c        **** 		}
  98:main.c        **** 		
  99:main.c        **** 		if(right && left < 80){
 243               		.loc 1 99 0
 244 0102 4114      		cp r4,__zero_reg__	 ;  173	*cmphi/2	[length = 2]
 245 0104 5104      		cpc r5,__zero_reg__
 246 0106 01F0      		breq .L10	 ;  174	branch	[length = 1]
 247               		.loc 1 99 0 is_stmt 0 discriminator 1
 248 0108 0035      		cpi r16,80	 ;  180	*cmphi/6	[length = 2]
 249 010a 1105      		cpc r17,__zero_reg__
 250 010c 04F4      		brge .L11	 ;  181	branch	[length = 1]
 100:main.c        **** 			StatusLED(RED);
 251               		.loc 1 100 0 is_stmt 1
 252 010e 82E0      		ldi r24,lo8(2)	 ;  183	movqi_insn/2	[length = 1]
 253 0110 00D0      		rcall StatusLED	 ;  184	call_insn/2	[length = 1]
 254               	.LVL30:
 255               	.L11:
 101:main.c        **** 		}
 102:main.c        **** 		
 103:main.c        **** 		if(80 < right && left < 120){
 256               		.loc 1 103 0
 257 0112 91E5      		ldi r25,81	 ;  187	*cmphi/7	[length = 3]
 258 0114 4916      		cp r4,r25
 259 0116 5104      		cpc r5,__zero_reg__
 260 0118 04F0      		brlt .L12	 ;  188	branch	[length = 1]
 261               		.loc 1 103 0 is_stmt 0 discriminator 1
 262 011a 0837      		cpi r16,120	 ;  190	*cmphi/6	[length = 2]
 263 011c 1105      		cpc r17,__zero_reg__
 264 011e 04F4      		brge .L12	 ;  191	branch	[length = 1]
 104:main.c        **** 			StatusLED(YELLOW);
 265               		.loc 1 104 0 is_stmt 1
 266 0120 83E0      		ldi r24,lo8(3)	 ;  193	movqi_insn/2	[length = 1]
 267 0122 00D0      		rcall StatusLED	 ;  194	call_insn/2	[length = 1]
 268               	.LVL31:
 269               	.L12:
 105:main.c        **** 		}
 106:main.c        **** 		
 107:main.c        **** 		if(right && left > 120){
 270               		.loc 1 107 0 discriminator 1
 271 0124 0937      		cpi r16,121	 ;  200	*cmphi/6	[length = 2]
 272 0126 1105      		cpc r17,__zero_reg__
 273 0128 04F0      		brlt .L10	 ;  201	branch	[length = 1]
 108:main.c        **** 			StatusLED(GREEN);
 274               		.loc 1 108 0
 275 012a 81E0      		ldi r24,lo8(1)	 ;  203	movqi_insn/2	[length = 1]
 276 012c 00D0      		rcall StatusLED	 ;  204	call_insn/2	[length = 1]
 277               	.LVL32:
 278               	.L10:
 109:main.c        **** 		}
 110:main.c        **** 		
 111:main.c        **** 		
 112:main.c        **** 			if(x == 3000){
 279               		.loc 1 112 0
 280 012e E8EB      		ldi r30,-72	 ;  207	*cmphi/7	[length = 4]
 281 0130 EE16      		cp r14,r30
 282 0132 EBE0      		ldi r30,11
 283 0134 FE06      		cpc r15,r30
 284 0136 01F4      		brne .L15	 ;  208	branch	[length = 1]
 113:main.c        **** 				FrontLED(ON);
 285               		.loc 1 113 0
 286 0138 81E0      		ldi r24,lo8(1)	 ;  210	movqi_insn/2	[length = 1]
 287 013a 00D0      		rcall FrontLED	 ;  211	call_insn/2	[length = 1]
 288               	.LVL33:
 114:main.c        **** 				x=0;
 289               		.loc 1 114 0
 290 013c E12C      		mov r14,__zero_reg__	 ;  521	*movhi/2	[length = 2]
 291 013e F12C      		mov r15,__zero_reg__
 292 0140 00C0      		rjmp .L16	 ;  593	jump	[length = 1]
 293               	.LVL34:
 294               	.L15:
 115:main.c        **** 		    }
 116:main.c        **** 		    if(x == 15){				
 295               		.loc 1 116 0
 296 0142 FFE0      		ldi r31,15	 ;  219	*cmphi/7	[length = 3]
 297 0144 EF16      		cp r14,r31
 298 0146 F104      		cpc r15,__zero_reg__
 299 0148 01F4      		brne .L16	 ;  220	branch	[length = 1]
 117:main.c        **** 				FrontLED(OFF);
 300               		.loc 1 117 0
 301 014a 80E0      		ldi r24,0	 ;  222	movqi_insn/1	[length = 1]
 302 014c 00D0      		rcall FrontLED	 ;  223	call_insn/2	[length = 1]
 303               	.LVL35:
 118:main.c        **** 				x++;
 304               		.loc 1 118 0
 305 014e 90E1      		ldi r25,lo8(16)	 ;  583	*reload_inhi	[length = 3]
 306 0150 E92E      		mov r14,r25
 307 0152 F12C      		mov r15,__zero_reg__
 308 0154 00C0      		rjmp .L17	 ;  595	jump	[length = 1]
 309               	.LVL36:
 310               	.L16:
 119:main.c        **** 			}
 120:main.c        **** 			else{
 121:main.c        **** 				x++;
 311               		.loc 1 121 0
 312 0156 2FEF      		ldi r18,-1	 ;  230	addhi3_clobber/3	[length = 3]
 313 0158 E21A      		sub r14,r18
 314 015a F20A      		sbc r15,r18
 315               	.LVL37:
 316               	.L17:
 317 015c 8B8D      		ldd r24,Y+27	 ;  571	movqi_insn/4	[length = 1]
 318 015e 8271      		andi r24,lo8(18)	 ;  235	andqi3/2	[length = 1]
 122:main.c        **** 			}
 123:main.c        **** 			
 124:main.c        **** 			
 125:main.c        **** 		
 126:main.c        **** 		//Rückfahrt
 127:main.c        **** 		
 128:main.c        **** 		if (a_pressed || b_pressed > 0) {
 319               		.loc 1 128 0
 320 0160 01F0      		breq .L18	 ;  237	branch	[length = 1]
 129:main.c        **** 			StatusLED(RED);
 321               		.loc 1 129 0
 322 0162 82E0      		ldi r24,lo8(2)	 ;  239	movqi_insn/2	[length = 1]
 323 0164 00D0      		rcall StatusLED	 ;  240	call_insn/2	[length = 1]
 324               	.LVL38:
 130:main.c        **** 			BackLED(OFF,ON);
 325               		.loc 1 130 0
 326 0166 61E0      		ldi r22,lo8(1)	 ;  241	movqi_insn/2	[length = 1]
 327 0168 80E0      		ldi r24,0	 ;  242	movqi_insn/1	[length = 1]
 328 016a 00D0      		rcall BackLED	 ;  243	call_insn/2	[length = 1]
 329               	.LVL39:
 330               	.LBB24:
 331               	.LBB25:
 332               		.loc 2 346 0
 333 016c 84E2      		ldi r24,lo8(36)	 ;  246	movqi_insn/2	[length = 1]
 334 016e 00D0      		rcall sleep	 ;  247	call_insn/2	[length = 1]
 335               	.LVL40:
 336               	.LBE25:
 337               	.LBE24:
 131:main.c        **** 			msleep(1);
 132:main.c        **** 			BackLED(ON,OFF);
 338               		.loc 1 132 0
 339 0170 60E0      		ldi r22,0	 ;  250	movqi_insn/1	[length = 1]
 340 0172 81E0      		ldi r24,lo8(1)	 ;  251	movqi_insn/2	[length = 1]
 341 0174 00D0      		rcall BackLED	 ;  252	call_insn/2	[length = 1]
 342               	.LVL41:
 133:main.c        **** 			MotorDir(RWD,RWD);
 343               		.loc 1 133 0
 344 0176 60E1      		ldi r22,lo8(16)	 ;  253	movqi_insn/2	[length = 1]
 345 0178 80E1      		ldi r24,lo8(16)	 ;  254	movqi_insn/2	[length = 1]
 346 017a 00D0      		rcall MotorDir	 ;  255	call_insn/2	[length = 1]
 347               	.LVL42:
 134:main.c        **** 			MotorSpeed(120,120);
 348               		.loc 1 134 0
 349 017c 68E7      		ldi r22,lo8(120)	 ;  256	movqi_insn/2	[length = 1]
 350 017e 88E7      		ldi r24,lo8(120)	 ;  257	movqi_insn/2	[length = 1]
 351 0180 00D0      		rcall MotorSpeed	 ;  258	call_insn/2	[length = 1]
 352               	.LVL43:
 353 0182 08E5      		ldi r16,lo8(88)	 ;  522	*movhi/5	[length = 2]
 354 0184 12E0      		ldi r17,lo8(2)
 355               	.LVL44:
 356               	.L20:
 357               	.LBB26:
 358               	.LBB27:
 359               		.loc 2 346 0
 360 0186 84E2      		ldi r24,lo8(36)	 ;  263	movqi_insn/2	[length = 1]
 361 0188 00D0      		rcall sleep	 ;  264	call_insn/2	[length = 1]
 362               	.LVL45:
 363 018a 0150      		subi r16,1	 ;  268	addhi3_clobber/2	[length = 2]
 364 018c 1109      		sbc r17,__zero_reg__
 365               	.LVL46:
 345:../../libtinyasuro/inc/asuro/time.h ****         sleep(36);
 366               		.loc 2 345 0
 367 018e 0115      		cp r16,__zero_reg__	 ;  269	*cmphi/2	[length = 2]
 368 0190 1105      		cpc r17,__zero_reg__
 369 0192 01F4      		brne .L20	 ;  270	branch	[length = 1]
 370               	.LBE27:
 371               	.LBE26:
 135:main.c        **** 			msleep(600);
 136:main.c        **** 			MotorDir(BREAK,BREAK);
 372               		.loc 1 136 0
 373 0194 60E0      		ldi r22,0	 ;  279	movqi_insn/1	[length = 1]
 374 0196 80E0      		ldi r24,0	 ;  280	movqi_insn/1	[length = 1]
 375 0198 00D0      		rcall MotorDir	 ;  281	call_insn/2	[length = 1]
 376               	.LVL47:
 377               	.L18:
 378 019a 8B8D      		ldd r24,Y+27	 ;  572	movqi_insn/4	[length = 1]
 379 019c 8970      		andi r24,lo8(9)	 ;  284	andqi3/2	[length = 1]
 137:main.c        **** 		}
 138:main.c        **** 		
 139:main.c        **** 		if (c_pressed || d_pressed > 0) {
 380               		.loc 1 139 0
 381 019e 01F0      		breq .L21	 ;  286	branch	[length = 1]
 140:main.c        **** 			StatusLED(RED);
 382               		.loc 1 140 0
 383 01a0 82E0      		ldi r24,lo8(2)	 ;  288	movqi_insn/2	[length = 1]
 384 01a2 00D0      		rcall StatusLED	 ;  289	call_insn/2	[length = 1]
 385               	.LVL48:
 141:main.c        **** 			BackLED(OFF,ON);
 386               		.loc 1 141 0
 387 01a4 61E0      		ldi r22,lo8(1)	 ;  290	movqi_insn/2	[length = 1]
 388 01a6 80E0      		ldi r24,0	 ;  291	movqi_insn/1	[length = 1]
 389 01a8 00D0      		rcall BackLED	 ;  292	call_insn/2	[length = 1]
 390               	.LVL49:
 391               	.LBB28:
 392               	.LBB29:
 393               		.loc 2 346 0
 394 01aa 84E2      		ldi r24,lo8(36)	 ;  295	movqi_insn/2	[length = 1]
 395 01ac 00D0      		rcall sleep	 ;  296	call_insn/2	[length = 1]
 396               	.LVL50:
 397               	.LBE29:
 398               	.LBE28:
 142:main.c        **** 			msleep(1);
 143:main.c        **** 			BackLED(ON,OFF);
 399               		.loc 1 143 0
 400 01ae 60E0      		ldi r22,0	 ;  299	movqi_insn/1	[length = 1]
 401 01b0 81E0      		ldi r24,lo8(1)	 ;  300	movqi_insn/2	[length = 1]
 402 01b2 00D0      		rcall BackLED	 ;  301	call_insn/2	[length = 1]
 403               	.LVL51:
 144:main.c        **** 			MotorDir(RWD,RWD);
 404               		.loc 1 144 0
 405 01b4 60E1      		ldi r22,lo8(16)	 ;  302	movqi_insn/2	[length = 1]
 406 01b6 80E1      		ldi r24,lo8(16)	 ;  303	movqi_insn/2	[length = 1]
 407 01b8 00D0      		rcall MotorDir	 ;  304	call_insn/2	[length = 1]
 408               	.LVL52:
 145:main.c        **** 			MotorSpeed(120,60);
 409               		.loc 1 145 0
 410 01ba 6CE3      		ldi r22,lo8(60)	 ;  305	movqi_insn/2	[length = 1]
 411 01bc 88E7      		ldi r24,lo8(120)	 ;  306	movqi_insn/2	[length = 1]
 412 01be 00D0      		rcall MotorSpeed	 ;  307	call_insn/2	[length = 1]
 413               	.LVL53:
 414 01c0 08E5      		ldi r16,lo8(88)	 ;  523	*movhi/5	[length = 2]
 415 01c2 12E0      		ldi r17,lo8(2)
 416               	.LVL54:
 417               	.L23:
 418               	.LBB30:
 419               	.LBB31:
 420               		.loc 2 346 0
 421 01c4 84E2      		ldi r24,lo8(36)	 ;  312	movqi_insn/2	[length = 1]
 422 01c6 00D0      		rcall sleep	 ;  313	call_insn/2	[length = 1]
 423               	.LVL55:
 424 01c8 0150      		subi r16,1	 ;  317	addhi3_clobber/2	[length = 2]
 425 01ca 1109      		sbc r17,__zero_reg__
 426               	.LVL56:
 345:../../libtinyasuro/inc/asuro/time.h ****         sleep(36);
 427               		.loc 2 345 0
 428 01cc 0115      		cp r16,__zero_reg__	 ;  318	*cmphi/2	[length = 2]
 429 01ce 1105      		cpc r17,__zero_reg__
 430 01d0 01F4      		brne .L23	 ;  319	branch	[length = 1]
 431               	.LBE31:
 432               	.LBE30:
 146:main.c        **** 			msleep(600);
 147:main.c        **** 			MotorDir(BREAK,BREAK);
 433               		.loc 1 147 0
 434 01d2 60E0      		ldi r22,0	 ;  328	movqi_insn/1	[length = 1]
 435 01d4 80E0      		ldi r24,0	 ;  329	movqi_insn/1	[length = 1]
 436 01d6 00D0      		rcall MotorDir	 ;  330	call_insn/2	[length = 1]
 437               	.LVL57:
 438               	.L21:
 439 01d8 8B8D      		ldd r24,Y+27	 ;  573	movqi_insn/4	[length = 1]
 440 01da 8472      		andi r24,lo8(36)	 ;  333	andqi3/2	[length = 1]
 148:main.c        **** 		}
 149:main.c        **** 		
 150:main.c        **** 		if (e_pressed || f_pressed > 0) {
 441               		.loc 1 150 0
 442 01dc 01F0      		breq .L24	 ;  335	branch	[length = 1]
 151:main.c        **** 			StatusLED(RED);
 443               		.loc 1 151 0
 444 01de 82E0      		ldi r24,lo8(2)	 ;  337	movqi_insn/2	[length = 1]
 445 01e0 00D0      		rcall StatusLED	 ;  338	call_insn/2	[length = 1]
 446               	.LVL58:
 152:main.c        **** 			BackLED(OFF,ON);
 447               		.loc 1 152 0
 448 01e2 61E0      		ldi r22,lo8(1)	 ;  339	movqi_insn/2	[length = 1]
 449 01e4 80E0      		ldi r24,0	 ;  340	movqi_insn/1	[length = 1]
 450 01e6 00D0      		rcall BackLED	 ;  341	call_insn/2	[length = 1]
 451               	.LVL59:
 452               	.LBB32:
 453               	.LBB33:
 454               		.loc 2 346 0
 455 01e8 84E2      		ldi r24,lo8(36)	 ;  344	movqi_insn/2	[length = 1]
 456 01ea 00D0      		rcall sleep	 ;  345	call_insn/2	[length = 1]
 457               	.LVL60:
 458               	.LBE33:
 459               	.LBE32:
 153:main.c        **** 			msleep(1);
 154:main.c        **** 			BackLED(ON,OFF);
 460               		.loc 1 154 0
 461 01ec 60E0      		ldi r22,0	 ;  348	movqi_insn/1	[length = 1]
 462 01ee 81E0      		ldi r24,lo8(1)	 ;  349	movqi_insn/2	[length = 1]
 463 01f0 00D0      		rcall BackLED	 ;  350	call_insn/2	[length = 1]
 464               	.LVL61:
 155:main.c        **** 			MotorDir(RWD,RWD);
 465               		.loc 1 155 0
 466 01f2 60E1      		ldi r22,lo8(16)	 ;  351	movqi_insn/2	[length = 1]
 467 01f4 80E1      		ldi r24,lo8(16)	 ;  352	movqi_insn/2	[length = 1]
 468 01f6 00D0      		rcall MotorDir	 ;  353	call_insn/2	[length = 1]
 469               	.LVL62:
 156:main.c        **** 			MotorSpeed(60,120);
 470               		.loc 1 156 0
 471 01f8 68E7      		ldi r22,lo8(120)	 ;  354	movqi_insn/2	[length = 1]
 472 01fa 8CE3      		ldi r24,lo8(60)	 ;  355	movqi_insn/2	[length = 1]
 473 01fc 00D0      		rcall MotorSpeed	 ;  356	call_insn/2	[length = 1]
 474               	.LVL63:
 475 01fe 08E5      		ldi r16,lo8(88)	 ;  524	*movhi/5	[length = 2]
 476 0200 12E0      		ldi r17,lo8(2)
 477               	.LVL64:
 478               	.L26:
 479               	.LBB34:
 480               	.LBB35:
 481               		.loc 2 346 0
 482 0202 84E2      		ldi r24,lo8(36)	 ;  361	movqi_insn/2	[length = 1]
 483 0204 00D0      		rcall sleep	 ;  362	call_insn/2	[length = 1]
 484               	.LVL65:
 485 0206 0150      		subi r16,1	 ;  366	addhi3_clobber/2	[length = 2]
 486 0208 1109      		sbc r17,__zero_reg__
 487               	.LVL66:
 345:../../libtinyasuro/inc/asuro/time.h ****         sleep(36);
 488               		.loc 2 345 0
 489 020a 0115      		cp r16,__zero_reg__	 ;  367	*cmphi/2	[length = 2]
 490 020c 1105      		cpc r17,__zero_reg__
 491 020e 01F4      		brne .L26	 ;  368	branch	[length = 1]
 492               	.LBE35:
 493               	.LBE34:
 157:main.c        **** 			msleep(600);
 158:main.c        **** 			MotorDir(BREAK,BREAK);
 494               		.loc 1 158 0
 495 0210 60E0      		ldi r22,0	 ;  377	movqi_insn/1	[length = 1]
 496 0212 80E0      		ldi r24,0	 ;  378	movqi_insn/1	[length = 1]
 497 0214 00D0      		rcall MotorDir	 ;  379	call_insn/2	[length = 1]
 498               	.LVL67:
 499               	.L24:
 159:main.c        **** 		}
 160:main.c        **** 		
 161:main.c        **** 		if(counter>30){
 500               		.loc 1 161 0
 501 0216 8FE1      		ldi r24,31	 ;  382	*cmphi/7	[length = 3]
 502 0218 A816      		cp r10,r24
 503 021a B104      		cpc r11,__zero_reg__
 504 021c 04F0      		brlt .L27	 ;  383	branch	[length = 1]
 162:main.c        **** 			MotorDir(RWD,RWD);
 505               		.loc 1 162 0
 506 021e 60E1      		ldi r22,lo8(16)	 ;  385	movqi_insn/2	[length = 1]
 507 0220 80E1      		ldi r24,lo8(16)	 ;  386	movqi_insn/2	[length = 1]
 508 0222 00D0      		rcall MotorDir	 ;  387	call_insn/2	[length = 1]
 509               	.LVL68:
 163:main.c        **** 			MotorSpeed(60,60);
 510               		.loc 1 163 0
 511 0224 6CE3      		ldi r22,lo8(60)	 ;  388	movqi_insn/2	[length = 1]
 512 0226 8CE3      		ldi r24,lo8(60)	 ;  389	movqi_insn/2	[length = 1]
 513 0228 00D0      		rcall MotorSpeed	 ;  390	call_insn/2	[length = 1]
 514               	.LVL69:
 515 022a 0CE3      		ldi r16,lo8(60)	 ;  35	*movhi/5	[length = 2]
 516 022c 10E0      		ldi r17,0
 517               	.LVL70:
 518               	.L29:
 519               	.LBB36:
 520               	.LBB37:
 521               		.loc 2 346 0
 522 022e 84E2      		ldi r24,lo8(36)	 ;  395	movqi_insn/2	[length = 1]
 523 0230 00D0      		rcall sleep	 ;  396	call_insn/2	[length = 1]
 524               	.LVL71:
 525 0232 0150      		subi r16,1	 ;  400	addhi3_clobber/2	[length = 2]
 526 0234 1109      		sbc r17,__zero_reg__
 527               	.LVL72:
 345:../../libtinyasuro/inc/asuro/time.h ****         sleep(36);
 528               		.loc 2 345 0
 529 0236 0115      		cp r16,__zero_reg__	 ;  401	*cmphi/2	[length = 2]
 530 0238 1105      		cpc r17,__zero_reg__
 531 023a 01F4      		brne .L29	 ;  402	branch	[length = 1]
 532 023c 00C0      		rjmp .L48	 ;  599	jump	[length = 1]
 533               	.LVL73:
 534               	.L27:
 535               	.LBE37:
 536               	.LBE36:
 164:main.c        **** 			msleep(60);
 165:main.c        **** 			counter=0;
 166:main.c        **** 		}
 167:main.c        **** 		else{
 168:main.c        **** 			counter++;		
 537               		.loc 1 168 0
 538 023e 9FEF      		ldi r25,-1	 ;  411	addhi3_clobber/3	[length = 3]
 539 0240 A91A      		sub r10,r25
 540 0242 B90A      		sbc r11,r25
 541               	.LVL74:
 542 0244 00C0      		rjmp .L32	 ;  601	jump	[length = 1]
 543               	.LVL75:
 544               	.L48:
 165:main.c        **** 		}
 545               		.loc 1 165 0
 546 0246 A12C      		mov r10,__zero_reg__	 ;  525	*movhi/2	[length = 2]
 547 0248 B12C      		mov r11,__zero_reg__
 548               	.LVL76:
 549               	.L32:
 550 024a 8601      		movw r16,r12	 ;  575	*movhi/1	[length = 1]
 551 024c 000F      		lsl r16	 ;  582	*ashlhi3_const/2	[length = 2]
 552 024e 111F      		rol r17
 553 0250 060D      		add r16,r6	 ;  454	*addhi3/1	[length = 2]
 554 0252 171D      		adc r17,r7
 165:main.c        **** 		}
 555               		.loc 1 165 0 is_stmt 0 discriminator 1
 556 0254 412C      		mov r4,__zero_reg__	 ;  527	*movhi/2	[length = 2]
 557 0256 512C      		mov r5,__zero_reg__
 558               	.L31:
 559               	.LVL77:
 169:main.c        **** 	}	
 170:main.c        **** 	while(lineData[LEFT] || lineData[RIGHT] > 900){
 560               		.loc 1 170 0 is_stmt 1 discriminator 1
 561 0258 8F89      		ldd r24,Y+23	 ;  460	*movhi/3	[length = 2]
 562 025a 988D      		ldd r25,Y+24
 563 025c 892B      		or r24,r25	 ;  461	*cmphi/1	[length = 1]
 564 025e 01F0      		breq .L49	 ;  462	branch	[length = 1]
 565               	.L33:
 171:main.c        **** 		MotorDir(BREAK,BREAK);
 566               		.loc 1 171 0
 567 0260 60E0      		ldi r22,0	 ;  416	movqi_insn/1	[length = 1]
 568 0262 80E0      		ldi r24,0	 ;  417	movqi_insn/1	[length = 1]
 569 0264 00D0      		rcall MotorDir	 ;  418	call_insn/2	[length = 1]
 570               	.LVL78:
 571 0266 F801      		movw r30,r16	 ;  574	*movhi/1	[length = 1]
 572 0268 E40D      		add r30,r4	 ;  419	*addhi3/1	[length = 2]
 573 026a F51D      		adc r31,r5
 172:main.c        **** 		pressed[t]=pressed[t]+10;
 574               		.loc 1 172 0
 575 026c 8081      		ld r24,Z	 ;  420	*movhi/3	[length = 2]
 576 026e 9181      		ldd r25,Z+1
 577 0270 0A96      		adiw r24,10	 ;  421	addhi3_clobber/1	[length = 1]
 578 0272 9183      		std Z+1,r25	 ;  422	*movhi/4	[length = 2]
 579 0274 8083      		st Z,r24
 173:main.c        **** 		t++;
 580               		.loc 1 173 0
 581 0276 EFEF      		ldi r30,-1	 ;  423	addhi3_clobber/3	[length = 3]
 582 0278 CE1A      		sub r12,r30
 583 027a DE0A      		sbc r13,r30
 584               	.LVL79:
 585 027c F2E0      		ldi r31,2	 ;  425	addhi3_clobber/3	[length = 3]
 586 027e 4F0E      		add r4,r31
 587 0280 511C      		adc r5,__zero_reg__
 174:main.c        **** 		if(t == 10){
 588               		.loc 1 174 0
 589 0282 2AE0      		ldi r18,10	 ;  426	*cmphi/7	[length = 3]
 590 0284 C216      		cp r12,r18
 591 0286 D104      		cpc r13,__zero_reg__
 592 0288 01F4      		brne .L31	 ;  427	branch	[length = 1]
 175:main.c        **** 			MotorDir(FWD,FWD);
 593               		.loc 1 175 0
 594 028a 60E2      		ldi r22,lo8(32)	 ;  433	movqi_insn/2	[length = 1]
 595 028c 80E2      		ldi r24,lo8(32)	 ;  434	movqi_insn/2	[length = 1]
 596 028e 00D0      		rcall MotorDir	 ;  435	call_insn/2	[length = 1]
 597               	.LVL80:
 176:main.c        **** 			MotorSpeed(pressed[t],pressed[t]);
 598               		.loc 1 176 0
 599 0290 8D89      		ldd r24,Y+21	 ;  436	movqi_insn/4	[length = 1]
 600 0292 682F      		mov r22,r24	 ;  437	movqi_insn/1	[length = 1]
 601 0294 00D0      		rcall MotorSpeed	 ;  439	call_insn/2	[length = 1]
 602               	.LVL81:
 603               	.LBB38:
 604               	.LBB39:
 605               		.loc 2 346 0
 606 0296 84E2      		ldi r24,lo8(36)	 ;  442	movqi_insn/2	[length = 1]
 607 0298 00D0      		rcall sleep	 ;  443	call_insn/2	[length = 1]
 608               	.LVL82:
 609               	.LBE39:
 610               	.LBE38:
 177:main.c        **** 			msleep(1);
 178:main.c        **** 			t=0;
 611               		.loc 1 178 0
 612 029a C12C      		mov r12,__zero_reg__	 ;  528	*movhi/2	[length = 2]
 613 029c D12C      		mov r13,__zero_reg__
 614               	.LVL83:
 615 029e 00C0      		rjmp .L32	 ;  604	jump	[length = 1]
 616               	.LVL84:
 617               	.L49:
 170:main.c        **** 		MotorDir(BREAK,BREAK);
 618               		.loc 1 170 0 discriminator 2
 619 02a0 898D      		ldd r24,Y+25	 ;  464	*movhi/3	[length = 2]
 620 02a2 9A8D      		ldd r25,Y+26
 621 02a4 8538      		cpi r24,-123	 ;  465	*cmphi/7	[length = 2]
 622 02a6 9340      		sbci r25,3
 623 02a8 00F4      		brsh .L33	 ;  466	branch	[length = 1]
 624 02aa 00C0      		rjmp .L34	 ;  607	jump	[length = 1]
 625               	.LBE21:
 626               		.cfi_endproc
 627               	.LFE2:
 629               		.text
 630               	.Letext0:
 631               		.file 3 "/usr/lib/avr/include/stdint.h"
 632               		.file 4 "../../libtinyasuro/inc/asuro/sensors.h"
 633               		.file 5 "../../libtinyasuro/inc/asuro/led.h"
 634               		.file 6 "../../libtinyasuro/inc/asuro/motor.h"
 635               		.file 7 "../../libtinyasuro/inc/asuro/switches.h"
 636               		.file 8 "../../libtinyasuro/inc/asuro/asuro.h"
DEFINED SYMBOLS
                            *ABS*:00000000 main.c
     /tmp/ccKOLuYf.s:2      *ABS*:0000003e __SP_H__
     /tmp/ccKOLuYf.s:3      *ABS*:0000003d __SP_L__
     /tmp/ccKOLuYf.s:4      *ABS*:0000003f __SREG__
     /tmp/ccKOLuYf.s:5      *ABS*:00000000 __tmp_reg__
     /tmp/ccKOLuYf.s:6      *ABS*:00000001 __zero_reg__
     /tmp/ccKOLuYf.s:13     .text.startup.main:00000000 main

UNDEFINED SYMBOLS
Init
MotorSpeed
MotorDir
FrontLED
BackLED
StatusLED
LineData
PollSwitch
__divmodhi4
sleep
